<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python 网络编程部分知识点</title>
    <link href="undefined2019/11/29/py%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>2019/11/29/py%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="Python-提供了两个级别访问的网络服务。："><a href="#Python-提供了两个级别访问的网络服务。：" class="headerlink" title="Python 提供了两个级别访问的网络服务。："></a>Python 提供了两个级别访问的网络服务。：</h4><ul><li>低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。</li><li>高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。</li></ul><h4 id="什么是-Socket"><a href="#什么是-Socket" class="headerlink" title="什么是 Socket?"></a>什么是 Socket?</h4><p>Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</p><h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h4><p>Python 中，我们用 socket（）函数来创建套接字，语法格式如下：</p><p><code>socket.socket([family[, type[, proto]]])</code></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>family: 套接字家族可以使AF_UNIX或者AF_INET</li><li>type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM</li><li>protocol: 一般不填默认为0.</li></ul><p>Socket 对象(内建)方法</p><ul><li><p>服务器端套接字</p><ul><li>s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</li><li>s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</li><li>s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来</li></ul></li><li><p>客户端套接字</p><ul><li>s.connect()    主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</li><li>s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</li></ul></li><li><p>公共用途的套接字函数(部分)</p><ul><li>s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</li><li>s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</li><li>s.sendall()    完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</li><li>s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</li><li>s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</li><li>s.close() 关闭套接字</li></ul></li></ul><h4 id="Python-Internet-模块"><a href="#Python-Internet-模块" class="headerlink" title="Python Internet 模块"></a>Python Internet 模块</h4><p>以下列出了 Python 网络编程的一些重要模块：</p><table><thead><tr><th>协议</th><th>功能用处</th><th>端口号</th><th>Python 模块</th></tr></thead><tbody><tr><td>HTTP</td><td>网页访问</td><td>80</td><td>httplib, urllib, xmlrpclib</td></tr><tr><td>NNTP</td><td>阅读和张贴新闻文章，俗称为”帖子”</td><td>119</td><td>nntplib</td></tr><tr><td>FTP</td><td>文件传输</td><td>20</td><td>ftplib, urllib</td></tr><tr><td>SMTP</td><td>发送邮件</td><td>25</td><td>smtplib</td></tr><tr><td>POP3</td><td>接收邮件</td><td>110</td><td>poplib</td></tr><tr><td>IMAP4</td><td>获取邮件</td><td>143</td><td>imaplib</td></tr><tr><td>Telnet</td><td>命令行</td><td>23</td><td>telnetlib</td></tr><tr><td>Gopher</td><td>信息查找</td><td>70</td><td>gopherlib, urllib</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>append和extend的区别</title>
    <link href="undefined2019/11/14/extend%E5%92%8Cappend%E5%8C%BA%E5%88%AB/"/>
    <url>2019/11/14/extend%E5%92%8Cappend%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>list.append(object)向列表中添加一个对象object<br>list.extend(seq)把一个序列seq的内容添加到列表中</p><pre><code>student_name = [&#39;Lily&#39;, &#39;Ellen&#39;, &#39;Alice&#39;]new_name = [&#39;Emiliy&#39;, &#39;Joe&#39;]student_name.append(new_media)print student_name[&#39;Lily&#39;, &#39;Ellen&#39;, &#39;Alice&#39;, [&#39;Emiliy&#39;, &#39;Joe&#39;]]</code></pre><p>使用append的时候，是将new_name看作一个对象，整体打包添加到student_name对象中。</p><pre><code>student_name = [&#39;Lily&#39;, &#39;Ellen&#39;, &#39;Alice&#39;]new_name = [&#39;Emiliy&#39;, &#39;Joe&#39;]student_name.append(new_media)print student_name[&#39;Lily&#39;, &#39;Ellen&#39;, &#39;Alice&#39;, &#39;Emiliy&#39;, &#39;Joe&#39;]</code></pre><p>使用extend的时候，是将new_name看作一个序列，将这个序列和student_name序列合并，并放在其后面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>if__name__==&#39;__main__&#39;的使用</title>
    <link href="undefined2019/11/10/name_main/"/>
    <url>2019/11/10/name_main/</url>
    
    <content type="html"><![CDATA[<p>一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。</p><p><code>if__name__==&#39;__main__&#39;</code>的作用就是控制这两种情况执行代码的过程，在<code>if __name__ == &#39;__main__&#39;:</code> 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而import到其他脚本中是不会被执行的。</p><p><strong>name</strong>是当前模块名，当模块被直接运行时模块名为_main_，也就是当前的模块，当模块被导入时，模块名就不是<strong>main</strong>，即代码将不会执行。</p><p>每个python模块都包含内置的变量 <strong>name</strong>，当该模块被直接执行的时候，<strong>name</strong> 等于文件名（包含后缀 .py ）；如果该模块 import 到其他模块中，则该模块的 <strong>name</strong> 等于模块名称（不包含后缀.py）。</p><p>而 “<strong>main</strong>” 始终指当前执行模块的名称（包含后缀.py）。进而当模块被直接执行时，<strong>name</strong> == ‘main’ 结果为真;而当模块被import到其他模块中时，<strong>name</strong> == ‘<strong>main</strong>‘结果为假，就是不调用对应的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语言语法</title>
    <link href="undefined2019/10/24/python%E8%AF%AD%E8%A8%80/"/>
    <url>2019/10/24/python%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ul><li><p>变量作用 </p><ul><li>增强程序可读性，拒绝硬编码</li><li>对程序的修改效率有了显著提高</li></ul></li><li><p>变量命名规则</p><ul><li>变量名必须为字母或者下划线（或者汉字）开头，可以包含字母，下划线，数字，甚至汉字</li><li>不能使用python关键字和保留字<pre><code>- 常见关键字:if,else,while,for等</code></pre></li><li>区分大小写</li></ul></li><li><p>变量推荐命名法则</p><ul><li>使用英文单词或缩写，见名知意 </li><li>尽量不要使用汉字、汉语拼音命名 </li><li>驼峰命名法:由多个单词构成，除第一个单词外，其余首字母大写，如：myAge,myName </li><li>大驼峰:包括第一个单词在内的首字母都大写，如：MyAge,MyName</li><li>posix命名规则:由单词构成，全部小写，单词间用下划线连接，如:my_age,my_name</li></ul></li></ul><h2 id="2-Python基础类型"><a href="#2-Python基础类型" class="headerlink" title="2. Python基础类型"></a>2. Python基础类型</h2><ul><li>常量数字<ul><li>直接表示出来的数字就是常量数字，即常量数</li></ul></li></ul><table><thead><tr><th>数字类型</th><th>数字举例</th></tr></thead><tbody><tr><td>十进制整数</td><td>123, 56, -13</td></tr><tr><td>浮点数</td><td>1.21, -0.93847, 4e-12, 4.98e4</td></tr><tr><td>复数</td><td>3+56j, 4.6+7.83j</td></tr><tr><td>二进制开头（0b开头）</td><td>0b1001, 0b101</td></tr><tr><td>十六进制（0x）开头</td><td>oxfec, 0x12fd</td></tr><tr><td>八进制（0o开头）</td><td>0o432, 0o763</td></tr></tbody></table><p>  -补充:八进制在python2.x中可以以’0’或者’0o’开头，在python3.x中只能以’0o’开头</p><ul><li><p>整数</p><ul><li>整数通常指不带有小数部分的数字，包括自然数，0，负数等，如：23,-9</li><li>可以表示任意大的数字</li><li>整数的进制:2,8,10,16进制<ul><li>python中的二进制常量数由’0b’开头</li><li>python中的八进制常量数由’0o’开头</li><li>python中的十六进制常量数由’0x’开头</li></ul></li><li>不同进制直接的转换<ul><li>十进制转换成二进制: <code>bin()</code></li><li>十进制转换成八进制: <code>oct()</code></li><li>十进制转换成十六进制: <code>hex()</code></li><li>默认转换成的是十进制</li></ul></li></ul></li><li><p>浮点数</p><ul><li>定义:即我们日常理解的小数，3.0</li><li>表示形式:<ul><li>常见小数:带小数点，例如3.4,5.0</li><li>科学计数法，小数乘以10为底的指数，指数可以为负数，3243.234=3.243234×10^3=3.243234e3</li></ul></li></ul></li><li><p>复数</p><ul><li>由实部和虚部组成，中间用‘+’链接，虚部后跟‘j’表示</li><li>例如:3+4j,23.12+43.2j</li></ul></li></ul><h2 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3. 字符串类型"></a>3. 字符串类型</h2><h3 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h3><ul><li>表示文本信息的一种形式</li><li>排列有序</li><li>在非注释中，凡是用引号括起来的部分都是字符串</li><li>引号类型:<pre><code>* 单引号:&#39;&#39;* 双引号:&quot;&quot;* 三单引号:&#39;&#39;&#39;python&#39;&#39;&#39;* 三双引号:&quot;&quot;&quot;python&quot;&quot;&quot;</code></pre><h3 id="四种引号的区别"><a href="#四种引号的区别" class="headerlink" title="四种引号的区别"></a>四种引号的区别</h3></li><li>单引号，双引号认为没有区别</li><li>三单引号，三双引号被认为没有区别</li><li>三引号常用来表示多行字符串信息，或者在程序函数内部函数体开头表示函数说明<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3></li><li>转义字符:字符串中一些不太好表示的符号，比如换行，制表符等，连同一些需要特殊表示的符号，如单引号，为了表示这些符号，需要用一些特殊的形式，俗称转义，需要转义的符号俗称转义字符</li><li>转义字符:<ul><li>单引号:&#39;</li><li>双引号:&quot;</li><li>响铃:\a</li><li>反斜杠:\</li><li>换行:\n</li><li>水平制表符:\t</li><li>垂直制表符:\v</li><li>倒退:\b</li><li>空字符串，字符值为0:\0</li><li>unicode 16位的十六进制数值:\uxxxx(注意，是四个数字)</li><li>Unicode 32位的十六进制数值:\uxxxx xxxx(注意，u后边是8位数)</li><li>十六进制值:\xXX(注意，第一个x是必须有的，后边大X表示十六进制值)</li><li>八进制值:\oXX</li></ul></li></ul><h3 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h3><ul><li>把字符串按照一定格式进行打印或者填充</li><li>格式化的分类<pre><code> - 使用%进行格式化    ```### 占位符总共的种类       - %s:字符串       - %r:字符串，但是是使用repr而不是str       - %c:整数转换成单个字符       - %d:十进制整数       - %u:无符号整数       - %o:表示八进制       - %x:十六进制，字母为小写（x为小写）       - %X:十六进制，字母为大写（X为大写）       - %e:浮点数（e为小写），例如2.87e+12       - %E:浮点数（E为小写），例如2.87E+12       - %f,%F:浮点数十进制形式       - %g,%G:十进制形式浮点或者指数浮点自动转换       - 格式字符前出现整数表示此占位符所占位置的宽度       - 格式字符前出现‘-’表示左对齐       - 格式字符前出现‘+’表示右对齐       - 0位数不足用‘0’补齐       - width表示宽度       - pricision精度 ``` - 使用format函数</code></pre></li></ul><h2 id="4-String类型的API"><a href="#4-String类型的API" class="headerlink" title="4. String类型的API"></a>4. String类型的API</h2><ul><li>API(ApplicationProngrammingInterface应用程序接口)，是第三方已经做好的继承好的程序功能，我们需要的仅仅是调用，目的是最大程度上减少使用者的开发时间，提高使用者的开发效率。</li></ul><h3 id="1-一般函数"><a href="#1-一般函数" class="headerlink" title="1.一般函数"></a>1.一般函数</h3><ul><li><p>satrtswith/endswith</p><ul><li>判断是否以×××特定字符开头或结尾</li></ul></li><li><p>count</p><pre><code>- 计数，计算一个字符中某个子字符串出现的次数</code></pre></li><li><p>find</p><pre><code>- 查找字符串中子字符串出现的位置- 能查到，返回第一个查到的位置- 查不到结果，返回-1</code></pre></li></ul><h3 id="2-判断字符串"><a href="#2-判断字符串" class="headerlink" title="2.判断字符串"></a>2.判断字符串</h3><ul><li><p>起一定判断功能的字符串</p></li><li><p>islower/isupper</p><ul><li>判断字符串是小写字母还是大写字母</li><li>要求全部是瞎写或者大写才返回真值</li></ul></li><li><p>isdigit</p><ul><li>判断字符串是否是全部由数字符号组成</li></ul></li><li><p>isalpha</p><ul><li>判断字符串是否全部由字母组成</li><li>alpha是指英文字符表里面内容</li></ul></li></ul><h3 id="3-操作类函数"><a href="#3-操作类函数" class="headerlink" title="3.操作类函数"></a>3.操作类函数</h3><ul><li><p>lower/upper </p><pre><code>- 把字符串转换成大小写</code></pre></li><li><p>strip/lstrip/rstrip</p><pre><code>- 去掉空格</code></pre></li><li><p>swapcase</p><pre><code>- 字符串中字符交换大小写</code></pre></li></ul><h2 id="5-布尔变量"><a href="#5-布尔变量" class="headerlink" title="5. 布尔变量"></a>5. 布尔变量</h2><ul><li>表示真假</li><li>True/False</li><li>在编程当中，需要大量判断真假、是非、对错</li><li>None<ul><li>None是一个特殊的常量</li><li>不表示任何类型，通常用来占位，或者变量解除绑定，None与任何其他的类型进行比较永远返回False</li><li>作用：<ul><li>占位</li><li>解除变量绑定</li></ul></li></ul></li></ul><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><ul><li>运算符就是为数据提供运算链接的符号</li></ul><h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h3><ul><li>+,-,<em>,/,%(取余取模),//(地板除，得到的结果取整),*</em>(幂指数)</li><li>优先级<ul><li>三个等级<ul><li>1.**</li><li>2.*，/，%，//</li><li>+，-</li></ul></li><li>如果有括号，先计算括号内表达式</li></ul></li><li><em>表达式中如果出现浮点数，整数等，则计算结果为浮点数*</em></li></ul><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2.赋值运算符"></a>2.赋值运算符</h3><ul><li>为python变量提供赋值运算功能的符号</li><li>=,+=,-=,/=,%=,**=,//=</li></ul><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3.比较运算符"></a>3.比较运算符</h3><ul><li>为我们提供比较功能的运算符</li><li>特点是：最后的结果总是真或者假，即布尔值</li><li>&lt;,&gt;,&lt;=,&gt;=,==,!=</li></ul><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><ul><li>逻辑运算就是对布尔值进行运算</li><li>and,or,not</li></ul><h3 id="5-特殊运算符"><a href="#5-特殊运算符" class="headerlink" title="5.特殊运算符"></a>5.特殊运算符</h3><ul><li>is<ul><li>判断两个变量，对象是否同一个</li></ul></li><li>is not<ul><li>跟is操作符正好相反</li></ul></li><li>del<ul><li>用于删除变量，同时解除与对象的关联，如果可能则释放对象</li></ul></li></ul><h2 id="7-基本输入输出"><a href="#7-基本输入输出" class="headerlink" title="7.基本输入输出"></a>7.基本输入输出</h2><ul><li>input:从标准输入设备上读取一个字符串，末尾的换行符会被自动删除<ul><li>标准输入设备：一般指键盘</li><li>标准输出设备：屏幕</li><li>注意：input返回值永远是一个字符串类型</li></ul></li><li>print:输出/打印信息到标准输出设备</li></ul><h2 id="8-分支语句"><a href="#8-分支语句" class="headerlink" title="8.分支语句"></a>8.分支语句</h2><ul><li>程序可以由三种结构组成全部：程序结构=顺序+分支+循环</li><li>顺序：程序从上到下一行一行执行，一行执行完之后才会继续下一行</li><li>分支：通过一个判断条件，不同的结果对应不同的处理程序段</li><li>循环：多次重复执行相同的或相似的代码</li></ul><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li>判断一个条件，当条件成立，则执行相应的程序代码段</li><li>语法如下：<pre><code>if(条件表达式)：   程序处理模块</code></pre></li><li>python用缩进来表示程序结构或者代码的层级关系<ul><li>可以使用tab键或者空格</li><li>一个tab键表示几个空格可以设置</li><li>pass语句，占位符号，不执行任何语句，不起任何实际作用</li></ul></li></ul><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><ul><li>假设条件满足，则执行if后面的语句，否则，执行else后面的语句</li><li>else永远跟与他平级的if配对</li></ul><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><ul><li>元：操作数的意思，所谓三元，就是一个操作符带动三个操作数一起运算</li><li>三元运算符原本没有</li><li>语法：x if 条件 else y</li><li>表示：如果if条件判断为真，则返回值x，否则，返回值y</li></ul><h2 id="9-循环"><a href="#9-循环" class="headerlink" title="9.循环"></a>9.循环</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li>列表：用来盛放/表示一串性质相同或者相似的数据，这些数据组成有序的一种排列方式</li><li>一个列表可以盛放：数字。字符串。列表，或者其他复杂结构<ul><li>列表定义：直接表示列表，需要用中括号括起来，中间数据用逗号隔开</li></ul></li></ul><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><ul><li>一个函数</li><li>产生一个有规律的有数字组成的列表</li><li>使用包含三个参数：range(start,eng step)</li><li>start:开始数字，以后生成的列表里，包含这个数字作为第一个数字，默认为0</li><li>end:结束数字，这个数字不包含在range生成的列表里，例如range（1，5）就是生成[1,2,3,4]</li><li>step:步长，即每次增加多少，默认为1</li></ul><h3 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h3><ul><li>程序三大结构：顺序，分支，循环</li><li>循环：重复做一些性质相同或者相似的事情</li><li>Python循环：for，while</li><li>for：用关键字for来表示</li><li>for循环特点：有一个清晰的循环次数，或者清晰的循环结束标志等</li><li>语法：<pre><code>for i in xxx:  循环语句模块</code></pre></li></ul><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ul><li>当满足一定条件时才循环，具体循环多少次没有具体规定</li><li>语法：</li></ul><pre><code>while(循环条件)    循环体</code></pre><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><ul><li>continue含义：继续下一轮循环</li><li>使用环境：当我们已经确定不需要继续本轮循环的时候使用</li></ul><h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10.函数"></a>10.函数</h2><ul><li>能完成一定逻辑业务功能的程序块（一堆程序代码），是程序模块的一个单位</li><li>作用：<ul><li>代码组织</li><li>代码复用</li></ul></li><li>几个问题<ul><li>函数名/函数定义</li><li>参数</li><li>返回值</li></ul></li></ul><h3 id="函数返回值return语句"><a href="#函数返回值return语句" class="headerlink" title="函数返回值return语句"></a>函数返回值return语句</h3><ul><li>表示无条件结束函数并返回结果</li><li>约定，任一函数都应该有return语句表示结束，可以说return None</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>在函数中，用来占位具有一定表示意义的变量名</li><li>分类：<ul><li>形参：参数没有具体的值，主要作用是占据位置</li><li>实参：调用函数时，参数有了具体的值，也就有了具体的意义，此时叫实参</li></ul></li></ul><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><ul><li>对参数进行别名设置，同时使参数具有了默认值</li></ul><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul><li>参数在定义时带默认值</li><li>默认参数定义：<ul><li>默认参数需要使用关键字参数，语法格式为arg=xxx</li><li>必须放在参数列表后面，且默认参数后不得再有普通参数</li></ul></li></ul><h3 id="星号元组形参"><a href="#星号元组形参" class="headerlink" title="星号元组形参"></a>星号元组形参</h3><ul><li>星号元组参数</li><li>语法：<pre><code>def 函数名（*元组形参）：  语句块 </code></pre></li><li>如果不输入实参，则函数认为你给了一个空列表</li><li>如果输入实参，函数自动把实参打包放入列表，然后传入</li></ul><h3 id="双星号字典参数"><a href="#双星号字典参数" class="headerlink" title="双星号字典参数"></a>双星号字典参数</h3><ul><li><p>把传入参数打包成字典传入</p></li><li><p>语法：</p><pre><code>def 函数名（**字典形参）：  函数体</code></pre></li><li><p>双星号字典参数对应的是关键字参数</p></li></ul><h4 id="不定长参数说明："><a href="#不定长参数说明：" class="headerlink" title="不定长参数说明："></a>不定长参数说明：</h4><ul><li>位置形参，星号列表形参，双星号字典形参可以混用</li><li>如果混合使用，则顺序必须为位置形参，星号列表形参，双星号字典形参</li></ul><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul><li>返回值一般会有，用return语句返回</li><li>函数的类型，一般就是返回值的类型</li><li>不返回数据可以没有return，不建议去掉</li><li>如果不返回值，则默认返回None</li><li>函数可以返回复杂类型，也可以一次返回多个值</li><li>如果返回值放入一个变量中，则默认此变量为tuple类型，即多个返回值自动打包成tuple</li><li>还可以用相同序列变量来接收返回值，此时返回值会一对一存入相应变量</li><li>多个返回值函数接受只能是一个tuple类型或者相同数量变量列表</li></ul><h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><ul><li>函数文档值在函数开头起一定说明性的一段文字</li><li>通过查看<strong>doc</strong>属性可以查看函数定义的doc内容</li><li>函数定义的文档会出现在help函数结果中，供用户去查看</li></ul><h2 id="11-序列参数，字典参数"><a href="#11-序列参数，字典参数" class="headerlink" title="11.序列参数，字典参数"></a>11.序列参数，字典参数</h2><ul><li>列表参数：所有参数作为一个列表传入<ul><li>如果把列表直接传入，则解释器认为你只传入了一个参数</li><li>如果所有参数都放入一个列表中，则需要特殊表示出来 例：<code>myFunc01(*p1)</code></li><li>序列的长度必须与形参个数相同</li><li>序列位置信息对应相应的参数信息</li></ul></li><li>字典参数：所有参数作为一个字典传入<ul><li>如果所有参数都放入一个字典中，则需要特殊表示出来 例：<code>myFunc01(**p1)</code></li><li>字典的长度必须与形参的个数相同</li><li>字典的键必须对应函数的形参，键作为字符串类型</li><li>字典的值传递给键对应的参数</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队的应用——回文判断</title>
    <link href="undefined2019/10/20/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/"/>
    <url>2019/10/20/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>回文判断。称正读与反读都相同的字符序列为“回文序列”。 </p><p>试写一个算法，判断依次读入的一个以@为结束符的字母序列，是否为形如“序列1&amp;序列2”模式的字符序列。其中序列1和序列2的逆序列。例如，“a+b&amp;b+a”是属于该模式的字符序列，而“1+3&amp;3-1”则不是。</p><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>依次读入字符串中的字符，将已读字符放入顺序栈中，以‘@’为停止标志初始化两个空栈，先将字符串入栈l1，以‘&amp;’为分割点，将后半部分字符出栈在入栈到l2中，若最后l1,l2中出栈的字符相等，则是回文序列。否则，就不是回文序列。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX 10typedef struct stack{    char data[MAX];    int top;}stack;void InitStack(stack* l){    l-&gt;top = -1;}void PushStack(stack* l, char a){    if (l-&gt;top == MAX - 1)    {        return;    }    l-&gt;data[++l-&gt;top] = a;}char PopStack(stack* l){    if (l-&gt;top &lt; 0)    {        return 0;    }    else    {        char x;        x = l-&gt;data[l-&gt;top--];        return x;    }}void huiwen(){    char a;    int count = 1;    stack* l1, * l2;    l1 = (stack*)malloc(sizeof(stack));    l2 = (stack*)malloc(sizeof(stack));    InitStack(l1);    while (count)    {        do        {            a = getchar();            if (a == &#39;&amp;&#39;)            {                count = 0;            }            PushStack(l1, a);        } while (a != &#39;@&#39;);        if (count == 1)        {            printf(&quot;输入不合法，请重新输入\n&quot;);        }    }    InitStack(l2);    a = PopStack(l1);    while (a != &#39;&amp;&#39;)    {        a = PopStack(l1);        PushStack(l2, a);    }    while (l1-&gt;top &amp;&amp; l2-&gt;top)    {        if (PopStack(l1) != PopStack(l2))        {            printf(&quot;不是回文数\n&quot;);            return 0;        }        printf(&quot;是回文\n&quot;);        return 0;    }}int main(){    printf(&quot;请输入你要判断的序列：&quot;);    void InitStack(stack * l);    void PushStack(stack * l, char a);    char PopStack(stack * l);    huiwen();    return 0;}</code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="https://note.youdao.com/yws/api/personal/file/WEB23810244825e882153f695f0d17b354b?method=getImage&version=13&cstk=Ue62w9GA" srcset="/img/loading.gif" alt="ERROR"></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>还可以使用队和栈的结合，将每个已读字符放入顺序栈和链队列之中，以‘&amp;’字符为分割点，将字符分割成两个部分，前一部分存入栈中，后一部分存入队列，之后分别出栈出队，判断出栈出队的元素是否一致，若一致即为回文数，否则不是回文数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>StatusStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python——猜谜游戏小测试</title>
    <link href="undefined2019/10/16/%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F%E5%B0%8F%E6%B5%8B%E8%AF%95/"/>
    <url>2019/10/16/%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F%E5%B0%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>速写一个简单的猜谜游戏，即程序选择一个数字让用户来猜，在每一次猜测时，程序将告诉用户猜的数字比程序大还是小，当用户猜中数字时游戏结束。</p><p>该游戏的代码如下：</p><pre><code># _*_ coding:utf-8 _*_ # 开发团队：# 开发人员：Administrator# 开发时间：2019/10/1623:48# 文件名称：guess_name.py.py# 开发工具：PyCharmfrom random import randintdef play():    random_int = randint(0,100)    while True:        user_guess = int(input(&quot;What number did we guess (0-100)?&quot;))        if user_guess == random_int:            print(&quot;You found the number ({random_int}).Congrats!&quot;)            break        if user_guess &lt; random_int:            print(&quot;You number is less than the number we guessed.&quot;)            continue        if user_guess &gt; random_int:            print(&quot;You number is more than the number we guessed.&quot;)            continueif __name__ == &#39;__main__&#39;:    play()</code></pre><p>运行结果：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4ceb1b5fdc80e31fecc3cb39cde5cd26?method=getImage&version=5&cstk=WFAXD-O1" srcset="/img/loading.gif" alt="ERROR"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook的简单使用</title>
    <link href="undefined2019/10/11/jupyter%20notebook/"/>
    <url>2019/10/11/jupyter%20notebook/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Jupyter Notebooks 的本质是一个 Web 应用程序，支持实时代码，数学方程，可视化和 markdown。</p><p>Notebooks，不仅可以运行书写的python代码，同时还支持markdown格式的文本显示。</p><p>在Notebooks中还可以运行python</p><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>安装方式分为两种：</p><ul><li>Anaconda方法</li><li>pip方法</li></ul><h2 id="2-1Anaconda方法"><a href="#2-1Anaconda方法" class="headerlink" title="2.1Anaconda方法"></a>2.1Anaconda方法</h2><p>在Anaconda官网上下载安装包，在安装Anaconda的同时会安装Python和 Jupyter Notebooks这两个工具，并且还包含相当多数据科学和机器学习社区常用的软件包。</p><h2 id="2-2pip方法"><a href="#2-2pip方法" class="headerlink" title="2.2pip方法"></a>2.2pip方法</h2><p>我没试过…之后会尝试一下</p><h3 id="2-2-1安装python"><a href="#2-2-1安装python" class="headerlink" title="2.2.1安装python"></a>2.2.1安装python</h3><p>在安装python过程中记得选择PATH中添加环境变量</p><h3 id="2-2-2升级pip到最新版本"><a href="#2-2-2升级pip到最新版本" class="headerlink" title="2.2.2升级pip到最新版本"></a>2.2.2升级pip到最新版本</h3><p>安装python的同时会安装pip，但此时需要升级到最新版</p><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。</p><p>执行如下命令：</p><p><code>pip install --upgrade pip</code></p><h3 id="2-2-3安装Jupyter-Notebooks"><a href="#2-2-3安装Jupyter-Notebooks" class="headerlink" title="2.2.3安装Jupyter Notebooks"></a>2.2.3安装Jupyter Notebooks</h3><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。</p><p>执行如下命令：</p><p><code>pip install jupyter</code></p><h3 id="2-2-4启动Jupyter-Notebooks"><a href="#2-2-4启动Jupyter-Notebooks" class="headerlink" title="2.2.4启动Jupyter Notebooks"></a>2.2.4启动Jupyter Notebooks</h3><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。执行如下命令</p><p><code>jupyter notebooks</code></p><p>启动成功后，浏览器自动打开notebook窗口。此时显示的是Script文件夹下的文件目录。</p><p><strong>注意：启动notebooks之后，不要不要不要关闭该命令提示窗口，因为一旦关闭该窗口就会与本地服务器断开连接</strong></p><h2 id="三、jupyter-notebook基本使用"><a href="#三、jupyter-notebook基本使用" class="headerlink" title="三、jupyter notebook基本使用"></a>三、jupyter notebook基本使用</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB011839af16b758fcad8823e63bfdf3ec?method=getImage&version=8&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p>点击右侧的New按钮可展开下拉列表按钮，其内包括了可创建的四种工作环境：</p><ul><li>Python3：创建一个可以执行python代码的文件</li><li>Text File：创建文本类型的文件，后缀名为.txt</li><li>Folder：创建一个文件夹</li><li>Teminal：在浏览器中打开一的命令窗口</li></ul><h3 id="3-1jupyter-notebook-中编写并执行python代码"><a href="#3-1jupyter-notebook-中编写并执行python代码" class="headerlink" title="3.1jupyter notebook 中编写并执行python代码"></a>3.1jupyter notebook 中编写并执行python代码</h3><p>在首页右侧点击<code>New</code>，选择点击<code>Python3</code>,页面即跳转到一个新的窗口，此时已经创建了一个新的文件，该文件的名称(默认为Untitled)，点击即可修改文件名</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3f5c96ecc262c969de03b7ebe5a7cec8?method=getImage&version=9&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p>在<code>In [ ] :</code>后面的输入框中我们可以输入一段python代码进行测试，点击<code>Run</code>按钮执行,也可以快捷键<code>Ctrl+Enter</code>执行代码</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB11859ecf9a529c3e0c5a10f220c6c021?method=getImage&version=10&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p><strong>在jupyter notebook中代码可以直接运行得出结果</strong></p><h3 id="3-2jupyter-notebook-中使用Markdown添加文本"><a href="#3-2jupyter-notebook-中使用Markdown添加文本" class="headerlink" title="3.2jupyter notebook 中使用Markdown添加文本"></a>3.2jupyter notebook 中使用Markdown添加文本</h3><p>在jupyter notebook中还可以使用MarkDown添加解释性文本，code下拉栏显示是markdown类型，这时就可以使用MarkDown语法进行编写文本了，同时代码里print 的内容都是以markdown的格式显示的。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3b100e65a38a1d129f4fb9abb8034683?method=getImage&version=11&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><h2 id="四、jupyter-notebook中的常用的快捷键"><a href="#四、jupyter-notebook中的常用的快捷键" class="headerlink" title="四、jupyter notebook中的常用的快捷键"></a>四、jupyter notebook中的常用的快捷键</h2><p><code>Ctrl + Enter</code>: 执行单元格代码</p><p><code>Shift + Enter</code>: 执行单元格代码并且移动到下一个单元格</p><p><code>Alt + Enter</code>: 执行单元格代码，新建并移动到下一个单元格</p><p>这几个快捷键都是在编写程序的时候经常用到的。</p><p>其他的快捷键可以在命令模式下按<code>H</code>或点击<code>Help</code>中<code>Keyboard Shortcuts</code>查询</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python pip 安装工具包找不到时的问题与解决</title>
    <link href="undefined2019/10/09/python%20pip/"/>
    <url>2019/10/09/python%20pip/</url>
    
    <content type="html"><![CDATA[<h1 id="python-pip-安装一些包找不到的问题-Could-not-find-a-version-that-satisfies…"><a href="#python-pip-安装一些包找不到的问题-Could-not-find-a-version-that-satisfies…" class="headerlink" title="python pip 安装一些包找不到的问题 Could not find a version that satisfies…."></a>python pip 安装一些包找不到的问题 Could not find a version that satisfies….</h1><h2 id="有时候下载python自带的pip安装一些工具包时，会报如下错误"><a href="#有时候下载python自带的pip安装一些工具包时，会报如下错误" class="headerlink" title="有时候下载python自带的pip安装一些工具包时，会报如下错误"></a>有时候下载python自带的pip安装一些工具包时，会报如下错误</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB21c5da813082524db1ad778a58f26ed6?method=getImage&version=12&cstk=38kKjVFP" srcset="/img/loading.gif" alt="avatar"></p><p>找不到满意的版本，说明pip可能需要升级了，所以使用</p><p><code>python -m pip install --upgrade pip</code></p><p>升级一下pip ，–upgrade 后面跟的是需要升级的库名</p><p>也有可能是网络的问题，可以使用国内镜像比如豆瓣的镜像:</p><p><code>pip install package-name -i https://pypi.doubanio.com/simple/ --trusted-host pypi.douban.com</code></p><p>–trusted-host pypi.douban.com 这是为了获得ssl证书的认证</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——单链表</title>
    <link href="undefined2019/10/07/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/07/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义与表示"><a href="#单链表的定义与表示" class="headerlink" title="单链表的定义与表示"></a>单链表的定义与表示</h1><p>线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了正确表示结点之间的逻辑关系，必须在存储线性表的每个数据元素值的同时，存储指示其后继结点的地址（或位置）信息，这两部分信息组成的存储映像称为结点。</p><p>结点包括两个域：<strong>数据域</strong>用来存储结点的值，<strong>指针域</strong>用来存储数据元素的直接后继的地址（或位置）。</p><h1 id="单链表上的基本运算"><a href="#单链表上的基本运算" class="headerlink" title="单链表上的基本运算"></a>单链表上的基本运算</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>【算法步骤】</p><ol><li>生成新结点作为头结点，用头指针L指向头结点。</li><li>头结点的指针域置空。</li></ol><pre><code>InitList(LinkList *L){    *L=(Linklist)malloc(sizeof(Node));/*建立头结点*/    (*L)-&gt;next=NULL;/*建立空的单链表L*/}</code></pre><h2 id="建立（前插法）"><a href="#建立（前插法）" class="headerlink" title="建立（前插法）"></a>建立（前插法）</h2><p>【算法步骤】</p><ol><li>创建一个只有头结点的空链表</li><li>根据待创建链表包括的元素个数n，循环n次执行以下操作：<ul><li>生成一个新结点*p；</li><li>输入元素值赋给新结点*P的数据域；</li><li>将新结点*p插入到头结点之后。</li></ul></li></ol><pre><code>void CreatList_H(LinkList &amp;L,int n);{//头插法逆位序输入n个元素的值，建立带表头结点的单链表L        Node * s;          char c;          int flag=1;          while (flag)//flag初值为1，当输入‘$’时，置flag为0，建表结束       {                c=getchar();                if (c !=&#39;$&#39;)                {                        p=(Node*)malloc(sizeof(Node)); //建立一个新节点                        p-&gt;data=c;//输入元素值赋给新结点*p的数据域                        p-&gt;next=L-&gt;next;                        L-&gt;next=p;//将新结点p插入到头结点之后                }                else flag=0;          }}</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>【算法步骤】</p><ol><li>用指针p指向首元结点。</li><li>从首元结点开始依次顺着链域next向下查找，只要当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：p指向下一个结点。</li><li>返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。</li></ol><pre><code>LNode *LocateElem(LinkList L, ElemType e);{//在带头结点的单链表L中查找值为e的元素        p=L-&gt;next;//初始化，p指向首元结点        while(p&amp;&amp;p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e                p=p-&gt;next;        return p;}</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>【算法步骤】</p><ol><li>查找结点ai-1并由指针p指向该结点。</li><li>生成一个新结点*s。</li><li>将新结点*s的数据域置为e。</li><li>将新结点*s的指针域指向结点ai。</li><li>将结点<em>p的指针域指向新结点</em>s。</li></ol><pre><code>void ListInsert(LinkList &amp;L, int i, ElemType e);{//在第i个节点后插入值为e的新结点        p=L;        J=0;        while(p&amp;&amp;(j&lt;i-1))        {                p=p-&gt;next;                ++j;        }//查找第i-1个结点，p指向该结点        if(!p||j&lt;i-1) return ERROR;//i&gt;n+1或i&lt;1        s=new LNode;//生成新结点*s        s-&gt;data=e;//将结点*s的数据域置为e        s-&gt;next=p-&gt;next;//将结点*s的指针域指向结点ai        p-&gt;next-s;//将结点*p的指针域指向结点*s        return OK;}</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>【算法步骤】</p><ol><li>查找结点ai-1并由指针p指向该结点。</li><li>临时保存待删除结点ai的地址在q中，以备释放。</li><li>将结点*p的指针域指向ai的直接后继结点。</li><li>释放结点ai的空间。</li></ol><pre><code>void ListDelete(LinkList &amp;L, int i);{//删除第i个元素        p=L;        J=0;        while((p-&gt;next)&amp;&amp;(j&lt;i-1))        {                p=p-&gt;next;                ++j;        }//查找第i-1个结点，p指向该结点        if(!(p-&gt;next)||j&gt;i-1) return ERROR;//当i&gt;n或i&lt;1时，删除位置不合理        q=p-&gt;next;//临时保存被删结点的地址以备释放        p-&gt;next=q-&gt;next;//改变删除结点前驱结点的指针域        delete q;//释放删除结点的空间        return OK;}</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>【算法思想】</p><p>要求利用现有的表LA,LB中的结点空间来建立新表LC，可通过更改结点的next域来重接新的元素之间的线性关系。为保证新表仍然递增有序，可以利用尾插入法建立单链表的方法，只是新建表中的结点不用malloc，二只要从表LA,LB中选择合适的点插入到新表LC中即可。</p><pre><code>LinkList MergeLinkList(LinkList LA, LinkList LB){//将递增有序的链表LA,LB合并成一个递增有序的单链表LC        Node *pa,*pb;        LinkList LC;//将LC初始置空表，pa,pb分别指向两个单链表LA,LB的第一个结点，r初值为LC且r始终指向LC的表尾        pa=LA-&gt;next;        pb=LB-&gt;next;        LC=LA;        LC-&gt;next=NULL;        r=LC;//当两个表中均为处理完时，比较选择将较小值结点插入到新表LC中        while (pa!=NULL||pb!=NULL)        {                if(pa-&gt;data&lt;=pb-&gt;data)                {                        r-&gt;next=pa;                        r=pa;                        pa=pa-&gt;next;                }                else                {                        r-&gt;next=pb;                        r=pb;                        pb=pb-&gt;next;                }            }        if(pa)//若表LA未完，将表LA中后续元素链到新表LC表尾                r-&gt;next=pa;        else//否则将表LB中后续元素链到新表LC表尾                r-&gt;next=pb;        free(LB);        return(LC);}//MergeLinkList</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>void print(LinkList* list);//输出链表内容{//输出链表内容        Node *r=L-&gt;next;        while(r-&gt;next!=NULL)        {                printf(&quot;%d&quot;,r-&gt;data);                r=r-&gt;next;        }        printf(&quot;%d&quot;,r-&gt;data);}</code></pre><h2 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h2><p>【算法思想】</p><p>采用“数”结点的方法求出带头结点单链表的长度。即从“头”开始“数”（p-&gt;next），用指针p依次指向各个结点，并附设计数器j计数，一直“数”<br>到最后一个结点（p-&gt;next==NULL）,从而得到单链表的长度。</p><pre><code>int ListLength(LinkList L);{//确定链表的长度        Node *p;        p=L-&gt;next;        j=0;//用来存放单链表的长度        while(p!=NULL)        {                p=p-&gt;next;                j++;        }        return j;}//ListLength</code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code>int main(){        void CreatList_H(LinkList &amp;L,int n);//创建一个长度为n的带表头结点的链表        void GetElem(LinkList L, int i, ElemType &amp;e)//根据序号i获取元素的值，用e返回L中第i个数据元素的值        LNode *LocateElem(LinkList L, ElemType e);//查找值为e的元素        void ListInsert(LinkList &amp;L, int i, ElemType e);//在第i个节点后插入值为e的新结点        void ListDelete(LinkList &amp;L, int i);//删除第i个节点        LinkList MergeLinkList(LinkList LA, LinkList LB)//将递增有序的链表LA,LB合并成一个递增有序的单链表LC        void print(LinkList* list);//输出链表内容        int ListLength(LinkList L);//确定链表的长度}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>StatusStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——循环链表与双向链表</title>
    <link href="undefined2019/10/07/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/07/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表是一个首尾相接的链表。将单链表最后一个结点的指针域由NULL改为指向表头结点，就得到了单链形式的循环链表，称为循环单链表。</p><p>在循环单链表中，表中所有结点都被链在一个环上，为使某些操作实现方便，在循环单链表中也可设置一个头结点。这样，空循环链表仅由一个自成循环的头结点表示。</p><p>循环单链表与单链表的实现算法类似，差别仅在于算法中判别当前结点p是否为表尾结点的条件不同。</p><p>单链表中判别条件为<strong>p!=NULL或p-&gt;next!=NULL</strong>,而单循环链表的判别条件是p!=L或p-&gt;next!=L。</p><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><pre><code>InitCLinkList(LinkList *CL)/*CL用来接收待初始化的循环单链表的头指针变量的地址*/{    *CL = (LinkList)malloc(sizeof(Node)); /* 建立头结点*/    (*CL)-&gt;next=*CL; /*建立空的循环单链表CL*/}</code></pre><h2 id="2、建立"><a href="#2、建立" class="headerlink" title="2、建立"></a>2、建立</h2><pre><code>void CreateCLinkList(LinkList CL)/*CL是已经初始化好的、带头结点的空循环链表的头指针，通过键盘输入元素值，利用尾插法建立循环单链表CL*/{    Node *rear, *s;     char c;    rear = CL; /*rear指针动态指向链表的当前表尾，其初值指向头结点*/    c=gechar();/*读入第一个元素*/    while(c!=&#39;$&#39;)/*只要读入的元素不是结束标志，就存入新结点s并链到表尾，直到读入结束标志*/    {        s=(Node*)malloc(sizeof(Node));        s-&gt;data=c;        rear-&gt;next=s;        rear=s;        c=getchar();    }    rear-&gt;next=CL; /*让最后一个节点的next链域指向头结点}</code></pre><h2 id="3、合并"><a href="#3、合并" class="headerlink" title="3、合并"></a>3、合并</h2><p>【算法思想】</p><p>先找到两个链表LA,LB的表尾，并分别由指针p,q指向它们，然后将第一个链表的尾与第二个链表的第一个结点链接起来，并修改第二个表的表尾q，使它的链域指向第一个表的头结点。</p><pre><code>LinkList merge_1(LinkList LA，LinkList LB){    Node *p,*q;    p=LA;    q=LB;    while(p-&gt;next!=LA)         p=p-&gt;next; /*找到表LA的表尾，用p指向它*/    while(q-&gt;next!=LB)         q=q-&gt;next; /*找到表LB的表尾，用q指向它*/    q-&gt;next=LA;/*修改表LB的尾指针，使之指向表LA的头结点*/    p-&gt;next=LB-&gt;next;/*修改表LA的尾指针，使之指向表LB中的第一个结点*/    free(LB);    return(LA);}</code></pre><p>#双向链表</p><p>循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是O(n)。如果希望从表中快速确定某一个结点的前驱，另一个解决办法就是在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，称为双向链表。</p><p>在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><pre><code>//-----双向链表的存储结构-----typedef struct DuLNode{    ElemType data;//数据域    struct DuLNode *prior;//指向直接前驱    struct DuLNode *next;//指向直接后继}DuLNode,*DuLinkList;</code></pre><p>在双向链表中，若d为指向表中某一结点的指针，则显然有<strong>d-&gt;next-&gt;prior=d-&gt;prior-&gt;next=d</strong></p><p>在双向链表中，有些操作仅需涉及一个方向的指针，它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针。</p><h2 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h2><pre><code>status listinsert_dul(dulinklist &amp;L,int i,elemtype e){//在带头结点的双向链表L中第i个位置之前插入元素e    if(!(p=getelem_dul(L,i)))//在L中确定第i个元素的位置指针p        return ERROR;//p为NULL时，第i个元素不存在    s=dulnode;//生成新结点*s    s-&gt;data=e;//将结点*s数据域置为e    s-&gt;prior=p-&gt;prior;//将结点*s插入L中    p-&gt;prior-&gt;next=s;    s-&gt;next=p;    p-&gt;prior=s;    return OK;}</code></pre><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><pre><code>status listdelete_dul(dulinklist &amp;L，int i){//删除带头结点的双向链表L中的第i个元素    if(!(p=getelem_dul(L,i)))//在L中确定第i个元素的位置指针p        return ERROR;//p为NULL时。第i个元素不存在    p-&gt;prioe-&gt;next=p-&gt;next;//修改被删结点的前驱结点的后继指针    p-&gt;next-&gt;prior=p-&gt;prior;//修改被删结点的后继结点的前驱结点    delete p;//释放被删结点的空间    return OK;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>StatusStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——静态链表</title>
    <link href="undefined2019/10/06/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/06/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>在某些高级语言中没有提供“指针”这种数据类型，若想采用链表作存储结构，采用顺序存储结构数组模拟实现链表，在数组的每个表目中设置“游标（Cursor）”来模拟指针，由自己编写从数组中“分配结点”和“回收结点”的过程。这种方式被称为<strong>静态链表</strong>（Static Linked List）。</p><p><strong><em>静态链表和动态链表的区别</em></strong>：静态链表限制了数据元素存放的位置范围；动态链表是整个内存空间</p><p><strong>用游标模拟实现链表的方法</strong>：定义一个较大的结构数组作为结点空间存储池。每个结点应含有两个域，即data域和cursor域。data域用来存放结点的数据信息，此时的cursor域存放的不再是指针而是游标，游标存放的是其后继结点在结构数组中的相对位置（即数组下标值）。数组的第0个分量可以设计成表的头结点，头结点的cursor域指示了表中第一个结点的位置。表尾结点的cursor域为-1，表示静态链表的结束。</p><p>静态链表可以借助结构体数组来描述，为了方便我们进行插入数据，我们一般会把数组建立的大一些，以便有一些空闲空间可以便于插入时不至于数据溢出。</p><pre><code class="#define">typedef struct{     ElemType data;     int cursor;}Component,StaticList[Maxsize];</code></pre><h1 id="静态链表的基本操作"><a href="#静态链表的基本操作" class="headerlink" title="静态链表的基本操作"></a>静态链表的基本操作</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>所谓初始化操作，是指将这个静态链表初始化一个空闲结点静态链表。设space为静态链表存储空间的首地址，av为备用链表的头指针。</p><pre><code>void initial(StaticList space,int *av){     int k;     space[0].cursor=-1;/*设置已用静态链表的头指针指向space空间位置0，space[0]相当于头结点*/     for(k=1;k&lt;Maxsize-1;k++)          space[k].cursor=k+1;/*连链*/     space[Maxsize-1].cursor=-1;/*标记链尾*/     *av=1/*设置备用链表头指针初值*/}/*initial*/</code></pre><p><strong>注意</strong>：已用空间头指针此时可视为单链表的头结点，备用空间头指针av指向空闲结点静态链表的第一个结点。</p><h2 id="分配结点空间"><a href="#分配结点空间" class="headerlink" title="分配结点空间"></a>分配结点空间</h2><p>对系统而言，在空闲结点链表中分配结点空间相当于空闲结点链表中减少（删除）一个结点，对使用者而言，相当于申请得到了一个可用的新结点。</p><pre><code>int getnode(StaticList space,int *av)/*从备用链表摘下一个结点空间，分配给待插入静态链表中的元素*/{     int i;     i=*av;     *av=space[*av].cursor;     return i;}</code></pre><h2 id="回收结点空间"><a href="#回收结点空间" class="headerlink" title="回收结点空间"></a>回收结点空间</h2><p>对系统而言，空闲结点链表回收空闲结点相当于空闲结点链表中增加一个结点，对使用者而言，相当于释放了一个不用的结点。</p><pre><code>void freenode(StaticList space,int *av,int k)/*从space备用链表中回收序号为k的结点，av为备用链表的头指针*/{     space[k].cursor=*av;     *av=k;}</code></pre><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre><code>//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，a表示要插入的数据void insertArr(component * array,int body,int add,char a){    int tempBody=body;//tempBody做遍历结构体数组使用    //找到要插入位置的上一个结点在数组中的位置    for (int i=1; i&lt;add; i++)     {        tempBody=array[tempBody].cur;    }    int insert=mallocArr(array);//申请空间，准备插入    array[insert].data=a;    array[insert].cur=array[tempBody].cur;//新插入结点的游标等于其直接前驱结点的游标    array[tempBody].cur=insert;//直接前驱结点的游标等于新插入结点所在数组中的下标</code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>静态链表中删除指定元素，只需实现以下 2 步操作：<br>1、将存有目标元素的节点从数据链表中摘除；<br>2、将摘除节点添加到备用链表，以便下次再用；</p><pre><code>//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标void freeArr(component *array,int k){    array[k].cur=array[0].cur;    array[0].cur=k;}//删除结点函数，a 表示被删除结点中数据域存放的数据void deletArr(component *array,int body,char a){    int tempBody=body;    //找到被删除结点的位置    while (array[tempBody].data!=a)     {        tempBody=array[tempBody].cur;        //当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点        if (tempBody==0)        {            printf(&quot;链表中没有此数据&quot;);            return;        }    }    //运行到此，证明有该结点    int del=tempBody;    tempBody=body;    //找到该结点的上一个结点，做删除操作    while (array[tempBody].cur!=del)     {        tempBody=array[tempBody].cur;    }    //将被删除结点的游标直接给被删除结点的上一个结点    array[tempBody].cur=array[del].cur;    //回收被摘除节点的空间    freeArr(array, del);}</code></pre><h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。</p><pre><code>//在以body作为头结点的链表中查找数据域为elem的结点在数组中的位置int selectElem(component *array,int body,char elem){    int tempBody=body;    //当游标值为0时，表示链表结束    while (array[tempBody].cur!=0)     {        if (array[tempBody].data==elem)         {            return tempBody;        }        tempBody=array[tempBody].cur;    }    return -1;//返回-1，表示在链表中没有找到该元素}</code></pre><h2 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h2><p>更改静态链表中的数据，只需找到目标元素所在的节点，直接更改节点中的数据域即可。 </p><pre><code>//在以body作为头结点的链表中将数据域为oldElem的结点，数据域改为newElemvoid amendElem(component *array,int body,char oldElem,char newElem){    int add=selectElem(array, body, oldElem);    if (add==-1)    {        printf(&quot;无更改元素&quot;);        return;    }    array[add].data=newElem;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>StatusStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法小结</title>
    <link href="undefined2019/09/29/MarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <url>2019/09/29/MarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>#MarkDown语法小结 </p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用 <code>#</code> 表示标题，一级标题使用一个 <code>#</code> ，二级标题使用两个 <code>##</code> ，以此类推，共有六级标题。</li><li>使用 <code>=====</code> 表示高阶标题，使用 <code>---------</code> 表示次阶标题。</li></ul><ol><li><code>#</code> 和标题之间记得有个空格哦。</li><li><code>====</code> 和 <code>----</code> 表示标题时，大于等于2个都可以表示。</li><li>我通常在标题分级时使用标题标记，这个的用处很明了了。</li></ol><p>示例1</p><pre><code># 这是一级标题这也是一级标题========## 这是二级标题这也是二级标题--------------</code></pre><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h2 id="这也是二级标题"><a href="#这也是二级标题" class="headerlink" title="这也是二级标题"></a>这也是二级标题</h2><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>使用 <code>&gt;</code> 表示引用， <code>&gt;&gt;</code> 表示引用里面再套一层引用，依次类推。</p><ol><li>如果 <code>&gt;</code> 和 <code>&gt;&gt;</code> 嵌套使用的话，从 <code>&gt;&gt;</code> 退到 <code>&gt;</code> 时，必须之间要加一个空格或者 <code>&gt;</code> 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。 </li><li>引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。 </li></ol><p>示例 </p><pre><code>&gt; 这是一级引用&gt;&gt;这是二级引用&gt;&gt;&gt; 这是三级引用&gt;这是一级引用</code></pre><blockquote><p>这是一级引用</p><blockquote><p>这是二级引用</p><blockquote><p>这是三级引用</p></blockquote></blockquote></blockquote><blockquote><p>这是一级引用</p></blockquote><h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3 代码块"></a>3 代码块</h3><p>使用3个连续的”`”符号包围起来表示代码块。</p><ol><li>本文档所有使用讲解Markdown语法标记示例的地方都是使用代码块标记的。</li><li>代码块前后都得有换行哦</li></ol><pre><code>$(document).ready(function() {  $(&#39;pre code&#39;).each(function(i, block) {    hljs.highlightBlock(block);  });});</code></pre><h3 id="4-行内代码"><a href="#4-行内代码" class="headerlink" title="4 行内代码"></a>4 行内代码</h3><p>使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。</p><p>示例</p><pre><code>这是`javascript`代码</code></pre><p>这是 <code>javascript</code> 代码</p><h4 id="5-链接"><a href="#5-链接" class="headerlink" title="5 链接"></a>5 链接</h4><p>使用 <code>[](link)</code> 表示行内链接。其中：</p><ul><li><code>[]</code> 内的内容为要添加链接的文字。</li><li><code>link</code> 为链接地址。</li></ul><p>示例</p><pre><code>我觉得[Markdown](https://appsto.re/cn/jK8Cbb.i)真是个方便的编辑器.</code></pre><p>我觉得<a href="https://appsto.re/cn/jK8Cbb.i" target="_blank" rel="noopener">Markdown</a>真是个方便的编辑器.</p><h3 id="6-数学公式"><a href="#6-数学公式" class="headerlink" title="6 数学公式"></a>6 数学公式</h3><p><code>$</code>包围的区块将会解析为数学公式，连续的<code>$$</code>将独占一行并居中显示</p><p>当 $a \ne 0$, 此方程式有两个解 $ax^2 + bx + c = 0$，他们是 </p><p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p><h3 id="7-导入图片"><a href="#7-导入图片" class="headerlink" title="7 导入图片"></a>7 导入图片</h3><p>使用 <code>![Alt text](/path/to/img.jpg)</code> 导入图片。其中：</p><ul><li><code>Alt text</code> 为如果图片无法显示时显示的文字；</li><li><code>/path/to/img.jpg</code> 为图片所在路径；</li></ul><p>点击辅助键盘中的添加图片按钮，<strong>Markdown</strong>会自动帮你帮你把图片上传到图片存储服务器，并补齐链接</p><p>示例</p><pre><code>![Markdown](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1569701098939&amp;di=ff20e6935f1d4085402df94ed4f5cc4a&amp;imgtype=0&amp;src=http%3A%2F%2Fcn.hdwall365.com%2Fwallpapers%2F1509%2FSydney-Opera-House-Australia-night-bridge-lights-sea-blue_m.jpg)</code></pre><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1569701098939&di=ff20e6935f1d4085402df94ed4f5cc4a&imgtype=0&src=http%3A%2F%2Fcn.hdwall365.com%2Fwallpapers%2F1509%2FSydney-Opera-House-Australia-night-bridge-lights-sea-blue_m.jpg" srcset="/img/loading.gif" alt="Markdown"></p><h3 id="8-ToDo-List"><a href="#8-ToDo-List" class="headerlink" title="8 ToDo List"></a>8 ToDo List</h3><pre><code>- [x] 支持数学公式- [x] 支持TodoList- [ ] 支持自定义样式- [ ] 支持自定义图床</code></pre><p>小写x表示已完成， 空格表示未完成</p><ul><li><input checked disabled type="checkbox"> 支持数学公式</li><li><input checked disabled type="checkbox"> 支持TodoList</li><li><input disabled type="checkbox"> 支持自定义样式</li><li><input disabled type="checkbox"> 支持自定义图床</li></ul><h3 id="9-粗体和斜体"><a href="#9-粗体和斜体" class="headerlink" title="9 粗体和斜体"></a>9 粗体和斜体</h3><ol><li>使用 <code>**</code> 或者 <code>__</code> 表示粗体。</li><li>使用 <code>*</code> 或者 <code>_</code> 表示斜体。</li><li>前后的 <code>*</code> 或 <code>_</code> 与要 <strong>加粗或倾斜</strong> 的字体之间不能有空格。</li></ol><p>示例</p><pre><code> **粗体** *斜体*</code></pre><p><strong>粗体</strong></p><p><em>斜体</em></p><h3 id="10-列表"><a href="#10-列表" class="headerlink" title="10 列表"></a>10 列表</h3><p>使用 <code>1. 2. 3.</code> 表示有序列表，使用 <code>*</code> 或 <code>-</code> 或 <code>+</code> 表示无序列表。</p><ol><li>无序列表或有序列表标记和后面的文字之间要有一个空格隔开。</li><li>有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。</li><li>无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例2所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。</li></ol><h4 id="例1：有序列表"><a href="#例1：有序列表" class="headerlink" title="例1：有序列表"></a>例1：有序列表</h4><pre><code>1. 第一点2. 第二点4. 第三点</code></pre><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><h4 id="例2：无序列表"><a href="#例2：无序列表" class="headerlink" title="例2：无序列表"></a>例2：无序列表</h4><pre><code>+ 一级无序列表内容    * 二级无序列表内容    - 二级无序列表内容        - 三级无序列表内容        - 三级无序列表内容+ 一级无序列表内容    - 二级无序列表内容</code></pre><ul><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul><ul><li>二级无序列表内容<ul><li>三级无序列表内容</li><li>三级无序列表内容</li></ul></li></ul></li><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul></li></ul><h3 id="11-分割线"><a href="#11-分割线" class="headerlink" title="11 分割线"></a>11 分割线</h3><p>使用 <code>---</code> 或者 <code>***</code> 或者 <code>* * *</code> 表示水平分割线。</p><ol><li>只要 <code>*</code> 或者 <code>-</code> 大于等于三个就可组成一条平行线。</li><li>使用 <code>---</code> 作为水平分割线时，要在它的前后都空一行，防止 <code>---</code> 被当成标题标记的表示方式。</li></ol><p>示例</p><pre><code>---**** * *</code></pre><h3 id="12-删除线"><a href="#12-删除线" class="headerlink" title="12 删除线"></a>12 删除线</h3><p>使用 <code>~~</code> 表示删除线。</p><ol><li>注意 <code>~~</code> 和 要添加删除线的文字之间不能有空格。</li><li>我常使用在显示的告诉自己这行文字是要删除的。</li></ol><p>示例</p><pre><code>~~这是一条删除线~~</code></pre><p><del>这是一条删除线</del></p><h3 id="13表格"><a href="#13表格" class="headerlink" title="13表格"></a>13表格</h3><p>上面空一行下面空两行</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>添加边框:</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>对齐方式:</p><table><thead><tr><th align="left">Heading</th><th align="center">Heading</th><th align="right">Heading</th></tr></thead><tbody><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub搭建博客</title>
    <link href="undefined2019/09/29/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/09/29/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>#关于hexo与github使用过程中的问题与笔记 </p><p><strong>一、搭建个人博客前提：</strong></p><p><strong><em>Node.js、git</em></strong> 环境安装 </p><p><strong>二、Hexo安装</strong></p><p>安装Hexo </p><pre><code>npm install hexo -cli -g #安装hexo模块hexo init blog #通过hexo创建一个blog项目cd blog #打开blog文件夹npm installhexo server #开发服务</code></pre><p><strong>三、使用github</strong></p><p>GitHub中创建一个与用户名一致的仓库，以 <strong><em>io</em></strong> 为后缀，且一个账户只能建立一个。</p><p>如建立一个名叫<code>injoinD.github.io</code>的仓库，其中<code>injoinD</code>为用户名。</p><p><strong>四、配置git信息（Hexo和GitHub之间利用SSH通信）</strong></p><p>1.设置Git的user name和Email：</p><pre><code>git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;</code></pre><p>2.生成密钥</p><pre><code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></pre><p>打开以.ssh结尾的文件夹，将里面的内容配置到GitHub项目里的SSH and GPG keys中</p><p><strong>五、配置Deployment</strong></p><blockquote><p>在blog项目根目录下找到_config.yml文件，找到Deployment，做出如下修改：</p></blockquote><pre><code>deploy:  type: git  repo: git@github.com:yourname/yourname.github.io.git  branch: master</code></pre><p>如：仓库地址是<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:injoinD/injoinD.github.io.git,所以配置如下：</p><pre><code>deploy:  type: git  repo: git@github.com:injoinD/injoinD.github.io.git  branch: master</code></pre><p><strong>六、安装hexo-diployer-git自动部署发布工具</strong></p><pre><code>npm install hexo-deployer-git --save</code></pre><p><strong>七、生成静态文件部署到GitHub</strong></p><p>通过hexo命令，发布到GitHub上</p><pre><code>hexo g #生成网站静态文件到默认设置的 public 文件夹hexo d #自动生成网站静态文件，并部署到设定的仓库hexo clean #清除缓存文件 db.json 和已生成的静态文件 public</code></pre><p><strong><em>通过链接 injoinD.github.io即可访问 injoinD为自己的用户名</em></strong> </p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git&amp;github学习总结</title>
    <link href="undefined2019/09/26/Git&amp;GitHub%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>2019/09/26/Git&amp;GitHub%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="git-amp-github学习总结"><a href="#git-amp-github学习总结" class="headerlink" title="git&amp;github学习总结"></a>git&amp;github学习总结</h1><h3 id="1-Git的优势"><a href="#1-Git的优势" class="headerlink" title="1.Git的优势"></a>1.Git的优势</h3><ul><li>大部分操作在本地完成，不需要联网</li><li>完整性保证</li><li>尽可能添加数据而不是删除或修改数据</li><li>分支操作非常快捷流畅</li><li>与 Linux 命令全面兼容</li></ul><h3 id="2-Git的基本操作"><a href="#2-Git的基本操作" class="headerlink" title="2.Git的基本操作"></a>2.Git的基本操作</h3><ul><li><strong>2.1 状态查看</strong></li></ul><p><code>git stastus</code></p><blockquote><p>查看工作区、暂存区的状态</p></blockquote><ul><li><strong>2.2 添加</strong></li></ul><p><code>git add [file name]</code></p><blockquote><p>将工作区的“新建/修改”添加到暂存区</p></blockquote><ul><li><strong>2.3 提交</strong></li></ul><p><code>git commit -m &quot;commit message&quot; [file name]</code></p><blockquote><p>将暂存区的内容提交到本地库 </p></blockquote><ul><li><strong>2.4 查看历史记录</strong></li></ul><p><code>git log</code></p><blockquote><p>多屏显示控制方式： 空格向下翻页 b 向上翻页 q 退出</p></blockquote><ul><li><strong>2.5 前进后退</strong></li></ul><p><strong><em>本质：HEAD指针移动</em></strong></p><p>基于索引值操作[推荐]</p><p><code>git reset --hard [局部索引值]</code></p><p><code>git reset --hard a6ace91</code></p><blockquote><p>使用^符号：只能后退</p></blockquote><p><code>git reset --hard HEAD^</code></p><blockquote><p>注：一个^表示后退一步，n个表示后退n步<br>使用~符号：只能后退</p></blockquote><p><code>git reset --hard HEAD~n</code></p><blockquote><p>注：表示后退n步</p></blockquote><ul><li><p><strong>2.6 reset命令的三个参数对比</strong></p><ul><li><p>1.<br><code>--soft 参数</code></p><blockquote><p>仅仅在本地库移动HEAD指针</p></blockquote></li><li><p>2.<br><code>--mixed 参数</code></p><blockquote><p>在本地库移动 HEAD 指针</p><p>重置暂存区</p></blockquote></li><li><p>3.<br><code>--hard 参数</code></p><blockquote><p>在本地库移动HEAD指针</p><p>重置暂存区</p><p>重置工作区</p></blockquote></li></ul></li></ul><ul><li><p><strong>2.7 删除文件并找回</strong></p><ul><li>前提：删除前，文件存在时的状态提交到了本地库。</li><li>操作：<code>git reset --hard [指针位置]</code></li></ul></li></ul><pre><code>    &gt;删除操作已经提交到本地库：指针位置指向历史记录    &gt;    &gt;删除操作尚未提交到本地库：指针位置使用 HEAD</code></pre><ul><li><p><strong>2.8 比较文件差异</strong></p><ul><li><p><code>git diff [文件名]</code></p><blockquote><p>将工作区中的文件和暂存区进行比较</p></blockquote></li><li><p><code>git diff [本地库中历史版本] [文件名]</code></p><blockquote><p>将工作区中的文件和本地库历史记录比较 </p><p>不带文件名比较多个文件</p></blockquote></li></ul></li></ul><h3 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3.分支管理"></a>3.分支管理</h3><ul><li><p>3.1 什么是分支？ </p><pre><code>在版本控制过程中，使用多条线同时推进多个任务。</code></pre></li><li><p>3.2 分支的好处？</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任 何影响。失败的分支删除重新开始即可。 </li></ul></li><li><p>3.3 分支操作</p><ul><li><p>创建分支 <code>git branch [分支名]</code></p></li><li><p>查看分支 <code>git branch -v</code></p></li><li><p>切换分支 <code>git checkout [分支名]</code></p></li><li><p>合并分支</p><ul><li><p>第一步：切换到接受修改的分支（被合并，增加新内容）上 </p><p>   <code>git checkout [被合并分支名]</code></p></li><li><p>第二步：执行 <strong>merge</strong> 命令 </p><pre><code>`git merge [有新内容分支名]`</code></pre></li></ul></li></ul></li><li><p>3.4 冲突的解决</p><ul><li><p>第一步：编辑文件，删除特殊符号</p></li><li><p>第二步：把文件修改到满意的程度，保存退出</p></li><li><p>第三步：<code>git add [文件名]</code></p></li><li><p>第四步：<code>git commit -m &quot;日志信息&quot;</code></p><p>   <strong>注意：此时 commit 一定不能带具体文件名</strong></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dddddwen</title>
    <link href="undefined2019/09/25/duwen/"/>
    <url>2019/09/25/duwen/</url>
    
    <content type="html"><![CDATA[<p>搭博客的过程中虽然遇到了很多问题，但还是成功解决，拥有了属于自己的博客。</p><p>然后最近进入工作室的学习中，接触了很多新知识，现在只是略懂皮毛，希望快快将这些基础消化。</p><p>很感谢工作室各位的帮助，还是要谢谢宁哥，每周检查学习情况的制度不断督促着我，能让我按时完成学习任务。</p><p>最近逐渐开始步入正轨，接下来就要百分六十投入工作室，百分四十投入学习，在2019最后的三个月里，我想我会收获很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/25/hello-world/"/>
    <url>2019/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>