<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>猜谜游戏小测试</title>
    <link href="undefined2019/10/16/%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F%E5%B0%8F%E6%B5%8B%E8%AF%95/"/>
    <url>2019/10/16/%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F%E5%B0%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>速写一个简单的猜谜游戏，即程序选择一个数字让用户来猜，在每一次猜测时，程序将告诉用户猜的数字比程序大还是小，当用户猜中数字时游戏结束。</p><p>该游戏的代码如下：</p><pre><code>from random import randintdef play():    random_int = randint(0,100)    while True:        user_guess = int(input(&quot;What number did we guess (0-100)?&quot;))    if user_guess == randint:        print(&quot;You found the number ({random_int}).Congrats!&quot;)        break    if user_guess &lt; random_int:        print(&quot;You number is less than the number we guessed.&quot;)        continue    if user_guess &gt; random_int:        print(&quot;You number is more than the number we guessed.&quot;)        continueif __name__ == &#39;__main__&#39;:    paly()</code></pre><p>在PyCharm中提供</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook的简单使用</title>
    <link href="undefined2019/10/11/jupyter%20notebook/"/>
    <url>2019/10/11/jupyter%20notebook/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Jupyter Notebooks 的本质是一个 Web 应用程序，支持实时代码，数学方程，可视化和 markdown。</p><p>Notebooks，不仅可以运行书写的python代码，同时还支持markdown格式的文本显示。</p><p>在Notebooks中还可以运行python</p><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>安装方式分为两种：</p><ul><li>Anaconda方法</li><li>pip方法</li></ul><h2 id="2-1Anaconda方法"><a href="#2-1Anaconda方法" class="headerlink" title="2.1Anaconda方法"></a>2.1Anaconda方法</h2><p>在Anaconda官网上下载安装包，在安装Anaconda的同时会安装Python和 Jupyter Notebooks这两个工具，并且还包含相当多数据科学和机器学习社区常用的软件包。</p><h2 id="2-2pip方法"><a href="#2-2pip方法" class="headerlink" title="2.2pip方法"></a>2.2pip方法</h2><p>我没试过…之后会尝试一下</p><h3 id="2-2-1安装python"><a href="#2-2-1安装python" class="headerlink" title="2.2.1安装python"></a>2.2.1安装python</h3><p>在安装python过程中记得选择PATH中添加环境变量</p><h3 id="2-2-2升级pip到最新版本"><a href="#2-2-2升级pip到最新版本" class="headerlink" title="2.2.2升级pip到最新版本"></a>2.2.2升级pip到最新版本</h3><p>安装python的同时会安装pip，但此时需要升级到最新版</p><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。</p><p>执行如下命令：</p><p><code>pip install --upgrade pip</code></p><h3 id="2-2-3安装Jupyter-Notebooks"><a href="#2-2-3安装Jupyter-Notebooks" class="headerlink" title="2.2.3安装Jupyter Notebooks"></a>2.2.3安装Jupyter Notebooks</h3><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。</p><p>执行如下命令：</p><p><code>pip install jupyter</code></p><h3 id="2-2-4启动Jupyter-Notebooks"><a href="#2-2-4启动Jupyter-Notebooks" class="headerlink" title="2.2.4启动Jupyter Notebooks"></a>2.2.4启动Jupyter Notebooks</h3><p>打开命令提示窗，切换到python的安装目录下的Scripts文件夹。执行如下命令</p><p><code>jupyter notebooks</code></p><p>启动成功后，浏览器自动打开notebook窗口。此时显示的是Script文件夹下的文件目录。</p><p><strong>注意：启动notebooks之后，不要不要不要关闭该命令提示窗口，因为一旦关闭该窗口就会与本地服务器断开连接</strong></p><h2 id="三、jupyter-notebook基本使用"><a href="#三、jupyter-notebook基本使用" class="headerlink" title="三、jupyter notebook基本使用"></a>三、jupyter notebook基本使用</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB011839af16b758fcad8823e63bfdf3ec?method=getImage&version=8&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p>点击右侧的New按钮可展开下拉列表按钮，其内包括了可创建的四种工作环境：</p><ul><li>Python3：创建一个可以执行python代码的文件</li><li>Text File：创建文本类型的文件，后缀名为.txt</li><li>Folder：创建一个文件夹</li><li>Teminal：在浏览器中打开一的命令窗口</li></ul><h3 id="3-1jupyter-notebook-中编写并执行python代码"><a href="#3-1jupyter-notebook-中编写并执行python代码" class="headerlink" title="3.1jupyter notebook 中编写并执行python代码"></a>3.1jupyter notebook 中编写并执行python代码</h3><p>在首页右侧点击<code>New</code>，选择点击<code>Python3</code>,页面即跳转到一个新的窗口，此时已经创建了一个新的文件，该文件的名称(默认为Untitled)，点击即可修改文件名</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3f5c96ecc262c969de03b7ebe5a7cec8?method=getImage&version=9&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p>在<code>In [ ] :</code>后面的输入框中我们可以输入一段python代码进行测试，点击<code>Run</code>按钮执行,也可以快捷键<code>Ctrl+Enter</code>执行代码</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB11859ecf9a529c3e0c5a10f220c6c021?method=getImage&version=10&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><p><strong>在jupyter notebook中代码可以直接运行得出结果</strong></p><h3 id="3-2jupyter-notebook-中使用Markdown添加文本"><a href="#3-2jupyter-notebook-中使用Markdown添加文本" class="headerlink" title="3.2jupyter notebook 中使用Markdown添加文本"></a>3.2jupyter notebook 中使用Markdown添加文本</h3><p>在jupyter notebook中还可以使用MarkDown添加解释性文本，code下拉栏显示是markdown类型，这时就可以使用MarkDown语法进行编写文本了，同时代码里print 的内容都是以markdown的格式显示的。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3b100e65a38a1d129f4fb9abb8034683?method=getImage&version=11&cstk=38kKjVFP" srcset="/img/loading.gif" alt="ERROR"></p><h2 id="四、jupyter-notebook中的常用的快捷键"><a href="#四、jupyter-notebook中的常用的快捷键" class="headerlink" title="四、jupyter notebook中的常用的快捷键"></a>四、jupyter notebook中的常用的快捷键</h2><p><code>Ctrl + Enter</code>: 执行单元格代码</p><p><code>Shift + Enter</code>: 执行单元格代码并且移动到下一个单元格</p><p><code>Alt + Enter</code>: 执行单元格代码，新建并移动到下一个单元格</p><p>这几个快捷键都是在编写程序的时候经常用到的。</p><p>其他的快捷键可以在命令模式下按<code>H</code>或点击<code>Help</code>中<code>Keyboard Shortcuts</code>查询</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语言</title>
    <link href="undefined2019/10/10/python%E8%AF%AD%E8%A8%80/"/>
    <url>2019/10/10/python%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="1-第一个python程序"><a href="#1-第一个python程序" class="headerlink" title="1. 第一个python程序"></a>1. 第一个python程序</h2><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><ul><li><p>变量作用</p><ul><li>增强程序可读性，拒绝硬编码</li><li>对程序的修改效率有了显著提高</li></ul></li><li><p>变量命名规则</p><ul><li>变量名必须为字母或者下划线（或者汉字）开头，可以包含字母，下划线，数字，甚至汉字</li><li>不能使用python关键字和保留字<pre><code>- 常见关键字：if,else,while,for等</code></pre></li><li>区分大小写</li></ul></li><li><p>变量推荐命名法则</p><ul><li>使用英文单词或缩写，见名知意</li><li>尽量不要使用汉字、汉语拼音命名</li><li>驼峰命名法：由多个单词构成，除第一个单词外，其余首字母大写，如：myAge,myName</li><li>大驼峰：包括第一个单词在内的首字母都大写，如：MyAge,MyName</li><li>posix命名规则：由单词构成，全部小写，单词间用下划线连接，如：my_age,my_name</li></ul></li></ul><h2 id="3-Python基础类型"><a href="#3-Python基础类型" class="headerlink" title="3. Python基础类型"></a>3. Python基础类型</h2><ul><li>常量数字<ul><li>直接表示出来的数字就是常量数字，即常量数</li></ul></li></ul><table><thead><tr><th>数字类型</th><th>数字举例</th></tr></thead><tbody><tr><td>十进制整数</td><td>123, 56, -13</td></tr><tr><td>浮点数</td><td>1.21, -0.93847, 4e-12, 4.98e4</td></tr><tr><td>复数</td><td>3+56j, 4.6+7.83j</td></tr><tr><td>二进制开头（0b开头）</td><td>0b1001, 0b101</td></tr><tr><td>十六进制（0x）开头</td><td>oxfec, 0x12fd</td></tr><tr><td>八进制（0o开头）</td><td>0o432, 0o763</td></tr></tbody></table><p>  -补充：八进制在python2.x中可以以’0’或者’0o’开头，在python3.x中只能以’0o’开头</p><ul><li>整数<ul><li>整数通常指不带有小数部分的数字，包括自然数，0，负数等，如：23,-9</li><li>可以表示任意大的数字</li><li>整数的进制：2,8,10,16进制<ul><li>python中的二进制常量数由’0b’开头</li></ul></li></ul></li><li>浮点数</li><li>复数</li><li>bool作为数字使用</li></ul><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><h2 id="5-分支结构"><a href="#5-分支结构" class="headerlink" title="5. 分支结构"></a>5. 分支结构</h2><h2 id="6-循环结构"><a href="#6-循环结构" class="headerlink" title="6. 循环结构"></a>6. 循环结构</h2><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python pip 安装工具包找不到时的问题与解决</title>
    <link href="undefined2019/10/09/python%20pip/"/>
    <url>2019/10/09/python%20pip/</url>
    
    <content type="html"><![CDATA[<h1 id="python-pip-安装一些包找不到的问题-Could-not-find-a-version-that-satisfies…"><a href="#python-pip-安装一些包找不到的问题-Could-not-find-a-version-that-satisfies…" class="headerlink" title="python pip 安装一些包找不到的问题 Could not find a version that satisfies…."></a>python pip 安装一些包找不到的问题 Could not find a version that satisfies….</h1><h2 id="有时候下载python自带的pip安装一些工具包时，会报如下错误"><a href="#有时候下载python自带的pip安装一些工具包时，会报如下错误" class="headerlink" title="有时候下载python自带的pip安装一些工具包时，会报如下错误"></a>有时候下载python自带的pip安装一些工具包时，会报如下错误</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB21c5da813082524db1ad778a58f26ed6?method=getImage&version=12&cstk=38kKjVFP" srcset="/img/loading.gif" alt="avatar"></p><p>找不到满意的版本，说明pip可能需要升级了，所以使用</p><p><code>python -m pip install --upgrade pip</code></p><p>升级一下pip ，–upgrade 后面跟的是需要升级的库名</p><p>也有可能是网络的问题，可以使用国内镜像比如豆瓣的镜像:</p><p><code>pip install package-name -i https://pypi.doubanio.com/simple/ --trusted-host pypi.douban.com</code></p><p>–trusted-host pypi.douban.com 这是为了获得ssl证书的认证</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——循环链表与双向链表</title>
    <link href="undefined2019/10/07/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/07/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表是一个首尾相接的链表。将单链表最后一个结点的指针域由NULL改为指向表头结点，就得到了单链形式的循环链表，称为循环单链表。</p><p>在循环单链表中，表中所有结点都被链在一个环上，为使某些操作实现方便，在循环单链表中也可设置一个头结点。这样，空循环链表仅由一个自成循环的头结点表示。</p><p>循环单链表与单链表的实现算法类似，差别仅在于算法中判别当前结点p是否为表尾结点的条件不同。</p><p>单链表中判别条件为<strong>p!=NULL或p-&gt;next!=NULL</strong>,而单循环链表的判别条件是p!=L或p-&gt;next!=L。</p><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><pre><code>InitCLinkList(LinkList *CL)/*CL用来接收待初始化的循环单链表的头指针变量的地址*/{    *CL = (LinkList)malloc(sizeof(Node)); /* 建立头结点*/    (*CL)-&gt;next=*CL; /*建立空的循环单链表CL*/}</code></pre><h2 id="2、建立"><a href="#2、建立" class="headerlink" title="2、建立"></a>2、建立</h2><pre><code>void CreateCLinkList(LinkList CL)/*CL是已经初始化好的、带头结点的空循环链表的头指针，通过键盘输入元素值，利用尾插法建立循环单链表CL*/{    Node *rear, *s;     char c;    rear = CL; /*rear指针动态指向链表的当前表尾，其初值指向头结点*/    c=gechar();/*读入第一个元素*/    while(c!=&#39;$&#39;)/*只要读入的元素不是结束标志，就存入新结点s并链到表尾，直到读入结束标志*/    {        s=(Node*)malloc(sizeof(Node));        s-&gt;data=c;        rear-&gt;next=s;        rear=s;        c=getchar();    }    rear-&gt;next=CL; /*让最后一个节点的next链域指向头结点}</code></pre><h2 id="3、合并"><a href="#3、合并" class="headerlink" title="3、合并"></a>3、合并</h2><p>【算法思想】</p><p>先找到两个链表LA,LB的表尾，并分别由指针p,q指向它们，然后将第一个链表的尾与第二个链表的第一个结点链接起来，并修改第二个表的表尾q，使它的链域指向第一个表的头结点。</p><pre><code>LinkList merge_1(LinkList LA，LinkList LB){    Node *p,*q;    p=LA;    q=LB;    while(p-&gt;next!=LA)         p=p-&gt;next; /*找到表LA的表尾，用p指向它*/    while(q-&gt;next!=LB)         q=q-&gt;next; /*找到表LB的表尾，用q指向它*/    q-&gt;next=LA;/*修改表LB的尾指针，使之指向表LA的头结点*/    p-&gt;next=LB-&gt;next;/*修改表LA的尾指针，使之指向表LB中的第一个结点*/    free(LB);    return(LA);}</code></pre><p>#双向链表</p><p>循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是O(n)。如果希望从表中快速确定某一个结点的前驱，另一个解决办法就是在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，称为双向链表。</p><p>在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><pre><code>//-----双向链表的存储结构-----typedef struct DuLNode{    ElemType data;//数据域    struct DuLNode *prior;//指向直接前驱    struct DuLNode *next;//指向直接后继}DuLNode,*DuLinkList;</code></pre><p>在双向链表中，若d为指向表中某一结点的指针，则显然有<strong>d-&gt;next-&gt;prior=d-&gt;prior-&gt;next=d</strong></p><p>在双向链表中，有些操作仅需涉及一个方向的指针，它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针。</p><h2 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h2><pre><code>status listinsert_dul(dulinklist &amp;L,int i,elemtype e){//在带头结点的双向链表L中第i个位置之前插入元素e    if(!(p=getelem_dul(L,i)))//在L中确定第i个元素的位置指针p        return ERROR;//p为NULL时，第i个元素不存在    s=dulnode;//生成新结点*s    s-&gt;data=e;//将结点*s数据域置为e    s-&gt;prior=p-&gt;prior;//将结点*s插入L中    p-&gt;prior-&gt;next=s;    s-&gt;next=p;    p-&gt;prior=s;    return OK;}</code></pre><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><pre><code>status listdelete_dul(dulinklist &amp;L，int i){//删除带头结点的双向链表L中的第i个元素    if(!(p=getelem_dul(L,i)))//在L中确定第i个元素的位置指针p        return ERROR;//p为NULL时。第i个元素不存在    p-&gt;prioe-&gt;next=p-&gt;next;//修改被删结点的前驱结点的后继指针    p-&gt;next-&gt;prior=p-&gt;prior;//修改被删结点的后继结点的前驱结点    delete p;//释放被删结点的空间    return OK;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Circular Linked List  &amp;  Double Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——单链表</title>
    <link href="undefined2019/10/07/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/07/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义与表示"><a href="#单链表的定义与表示" class="headerlink" title="单链表的定义与表示"></a>单链表的定义与表示</h1><p>线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了正确表示结点之间的逻辑关系，必须在存储线性表的每个数据元素值的同时，存储指示其后继结点的地址（或位置）信息，这两部分信息组成的存储映像称为结点。</p><p>结点包括两个域：<strong>数据域</strong>用来存储结点的值，<strong>指针域</strong>用来存储数据元素的直接后继的地址（或位置）。</p><h1 id="单链表上的基本运算"><a href="#单链表上的基本运算" class="headerlink" title="单链表上的基本运算"></a>单链表上的基本运算</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>【算法步骤】</p><ol><li>生成新结点作为头结点，用头指针L指向头结点。</li><li>头结点的指针域置空。</li></ol><pre><code>InitList(LinkList *L){    *L=(Linklist)malloc(sizeof(Node));/*建立头结点*/    (*L)-&gt;next=NULL;/*建立空的单链表L*/}</code></pre><h2 id="建立（前插法）"><a href="#建立（前插法）" class="headerlink" title="建立（前插法）"></a>建立（前插法）</h2><p>【算法步骤】</p><ol><li>创建一个只有头结点的空链表</li><li>根据待创建链表包括的元素个数n，循环n次执行以下操作：<ul><li>生成一个新结点*p；</li><li>输入元素值赋给新结点*P的数据域；</li><li>将新结点*p插入到头结点之后。</li></ul></li></ol><pre><code>void CreatList_H(LinkList &amp;L,int n);{//头插法逆位序输入n个元素的值，建立带表头结点的单链表L        Node * s;          char c;          int flag=1;          while (flag)//flag初值为1，当输入‘$’时，置flag为0，建表结束       {                c=getchar();                if (c !=&#39;$&#39;)                {                        p=(Node*)malloc(sizeof(Node)); //建立一个新节点                        p-&gt;data=c;//输入元素值赋给新结点*p的数据域                        p-&gt;next=L-&gt;next;                        L-&gt;next=p;//将新结点p插入到头结点之后                }                else flag=0;          }}</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>【算法步骤】</p><ol><li>用指针p指向首元结点。</li><li>从首元结点开始依次顺着链域next向下查找，只要当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作：p指向下一个结点。</li><li>返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。</li></ol><pre><code>LNode *LocateElem(LinkList L, ElemType e);{//在带头结点的单链表L中查找值为e的元素        p=L-&gt;next;//初始化，p指向首元结点        while(p&amp;&amp;p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e                p=p-&gt;next;        return p;}</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>【算法步骤】</p><ol><li>查找结点ai-1并由指针p指向该结点。</li><li>生成一个新结点*s。</li><li>将新结点*s的数据域置为e。</li><li>将新结点*s的指针域指向结点ai。</li><li>将结点<em>p的指针域指向新结点</em>s。</li></ol><pre><code>void ListInsert(LinkList &amp;L, int i, ElemType e);{//在第i个节点后插入值为e的新结点        p=L;        J=0;        while(p&amp;&amp;(j&lt;i-1))        {                p=p-&gt;next;                ++j;        }//查找第i-1个结点，p指向该结点        if(!p||j&lt;i-1) return ERROR;//i&gt;n+1或i&lt;1        s=new LNode;//生成新结点*s        s-&gt;data=e;//将结点*s的数据域置为e        s-&gt;next=p-&gt;next;//将结点*s的指针域指向结点ai        p-&gt;next-s;//将结点*p的指针域指向结点*s        return OK;}</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>【算法步骤】</p><ol><li>查找结点ai-1并由指针p指向该结点。</li><li>临时保存待删除结点ai的地址在q中，以备释放。</li><li>将结点*p的指针域指向ai的直接后继结点。</li><li>释放结点ai的空间。</li></ol><pre><code>void ListDelete(LinkList &amp;L, int i);{//删除第i个元素        p=L;        J=0;        while((p-&gt;next)&amp;&amp;(j&lt;i-1))        {                p=p-&gt;next;                ++j;        }//查找第i-1个结点，p指向该结点        if(!(p-&gt;next)||j&gt;i-1) return ERROR;//当i&gt;n或i&lt;1时，删除位置不合理        q=p-&gt;next;//临时保存被删结点的地址以备释放        p-&gt;next=q-&gt;next;//改变删除结点前驱结点的指针域        delete q;//释放删除结点的空间        return OK;}</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>【算法思想】</p><p>要求利用现有的表LA,LB中的结点空间来建立新表LC，可通过更改结点的next域来重接新的元素之间的线性关系。为保证新表仍然递增有序，可以利用尾插入法建立单链表的方法，只是新建表中的结点不用malloc，二只要从表LA,LB中选择合适的点插入到新表LC中即可。</p><pre><code>LinkList MergeLinkList(LinkList LA, LinkList LB){//将递增有序的链表LA,LB合并成一个递增有序的单链表LC        Node *pa,*pb;        LinkList LC;//将LC初始置空表，pa,pb分别指向两个单链表LA,LB的第一个结点，r初值为LC且r始终指向LC的表尾        pa=LA-&gt;next;        pb=LB-&gt;next;        LC=LA;        LC-&gt;next=NULL;        r=LC;//当两个表中均为处理完时，比较选择将较小值结点插入到新表LC中        while (pa!=NULL||pb!=NULL)        {                if(pa-&gt;data&lt;=pb-&gt;data)                {                        r-&gt;next=pa;                        r=pa;                        pa=pa-&gt;next;                }                else                {                        r-&gt;next=pb;                        r=pb;                        pb=pb-&gt;next;                }            }        if(pa)//若表LA未完，将表LA中后续元素链到新表LC表尾                r-&gt;next=pa;        else//否则将表LB中后续元素链到新表LC表尾                r-&gt;next=pb;        free(LB);        return(LC);}//MergeLinkList</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>void print(LinkList* list);//输出链表内容{//输出链表内容        Node *r=L-&gt;next;        while(r-&gt;next!=NULL)        {                printf(&quot;%d&quot;,r-&gt;data);                r=r-&gt;next;        }        printf(&quot;%d&quot;,r-&gt;data);}</code></pre><h2 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h2><p>【算法思想】</p><p>采用“数”结点的方法求出带头结点单链表的长度。即从“头”开始“数”（p-&gt;next），用指针p依次指向各个结点，并附设计数器j计数，一直“数”<br>到最后一个结点（p-&gt;next==NULL）,从而得到单链表的长度。</p><pre><code>int ListLength(LinkList L);{//确定链表的长度        Node *p;        p=L-&gt;next;        j=0;//用来存放单链表的长度        while(p!=NULL)        {                p=p-&gt;next;                j++;        }        return j;}//ListLength</code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code>int main(){        void CreatList_H(LinkList &amp;L,int n);//创建一个长度为n的带表头结点的链表        void GetElem(LinkList L, int i, ElemType &amp;e)//根据序号i获取元素的值，用e返回L中第i个数据元素的值        LNode *LocateElem(LinkList L, ElemType e);//查找值为e的元素        void ListInsert(LinkList &amp;L, int i, ElemType e);//在第i个节点后插入值为e的新结点        void ListDelete(LinkList &amp;L, int i);//删除第i个节点        LinkList MergeLinkList(LinkList LA, LinkList LB)//将递增有序的链表LA,LB合并成一个递增有序的单链表LC        void print(LinkList* list);//输出链表内容        int ListLength(LinkList L);//确定链表的长度}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>LinkList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——静态链表</title>
    <link href="undefined2019/10/06/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <url>2019/10/06/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>在某些高级语言中没有提供“指针”这种数据类型，若想采用链表作存储结构，采用顺序存储结构数组模拟实现链表，在数组的每个表目中设置“游标（Cursor）”来模拟指针，由自己编写从数组中“分配结点”和“回收结点”的过程。这种方式被称为<strong>静态链表</strong>（Static Linked List）。</p><p><strong><em>静态链表和动态链表的区别</em></strong>：静态链表限制了数据元素存放的位置范围；动态链表是整个内存空间</p><p><strong>用游标模拟实现链表的方法</strong>：定义一个较大的结构数组作为结点空间存储池。每个结点应含有两个域，即data域和cursor域。data域用来存放结点的数据信息，此时的cursor域存放的不再是指针而是游标，游标存放的是其后继结点在结构数组中的相对位置（即数组下标值）。数组的第0个分量可以设计成表的头结点，头结点的cursor域指示了表中第一个结点的位置。表尾结点的cursor域为-1，表示静态链表的结束。</p><p>静态链表可以借助结构体数组来描述，为了方便我们进行插入数据，我们一般会把数组建立的大一些，以便有一些空闲空间可以便于插入时不至于数据溢出。</p><pre><code class="#define">typedef struct{     ElemType data;     int cursor;}Component,StaticList[Maxsize];</code></pre><h1 id="静态链表的基本操作"><a href="#静态链表的基本操作" class="headerlink" title="静态链表的基本操作"></a>静态链表的基本操作</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>所谓初始化操作，是指将这个静态链表初始化一个空闲结点静态链表。设space为静态链表存储空间的首地址，av为备用链表的头指针。</p><pre><code>void initial(StaticList space,int *av){     int k;     space[0].cursor=-1;/*设置已用静态链表的头指针指向space空间位置0，space[0]相当于头结点*/     for(k=1;k&lt;Maxsize-1;k++)          space[k].cursor=k+1;/*连链*/     space[Maxsize-1].cursor=-1;/*标记链尾*/     *av=1/*设置备用链表头指针初值*/}/*initial*/</code></pre><p><strong>注意</strong>：已用空间头指针此时可视为单链表的头结点，备用空间头指针av指向空闲结点静态链表的第一个结点。</p><h2 id="分配结点空间"><a href="#分配结点空间" class="headerlink" title="分配结点空间"></a>分配结点空间</h2><p>对系统而言，在空闲结点链表中分配结点空间相当于空闲结点链表中减少（删除）一个结点，对使用者而言，相当于申请得到了一个可用的新结点。</p><pre><code>int getnode(StaticList space,int *av)/*从备用链表摘下一个结点空间，分配给待插入静态链表中的元素*/{     int i;     i=*av;     *av=space[*av].cursor;     return i;}</code></pre><h2 id="回收结点空间"><a href="#回收结点空间" class="headerlink" title="回收结点空间"></a>回收结点空间</h2><p>对系统而言，空闲结点链表回收空闲结点相当于空闲结点链表中增加一个结点，对使用者而言，相当于释放了一个不用的结点。</p><pre><code>void freenode(StaticList space,int *av,int k)/*从space备用链表中回收序号为k的结点，av为备用链表的头指针*/{     space[k].cursor=*av;     *av=k;}</code></pre><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre><code>//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，a表示要插入的数据void insertArr(component * array,int body,int add,char a){    int tempBody=body;//tempBody做遍历结构体数组使用    //找到要插入位置的上一个结点在数组中的位置    for (int i=1; i&lt;add; i++)     {        tempBody=array[tempBody].cur;    }    int insert=mallocArr(array);//申请空间，准备插入    array[insert].data=a;    array[insert].cur=array[tempBody].cur;//新插入结点的游标等于其直接前驱结点的游标    array[tempBody].cur=insert;//直接前驱结点的游标等于新插入结点所在数组中的下标</code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>静态链表中删除指定元素，只需实现以下 2 步操作：<br>1、将存有目标元素的节点从数据链表中摘除；<br>2、将摘除节点添加到备用链表，以便下次再用；</p><pre><code>//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标void freeArr(component *array,int k){    array[k].cur=array[0].cur;    array[0].cur=k;}//删除结点函数，a 表示被删除结点中数据域存放的数据void deletArr(component *array,int body,char a){    int tempBody=body;    //找到被删除结点的位置    while (array[tempBody].data!=a)     {        tempBody=array[tempBody].cur;        //当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点        if (tempBody==0)        {            printf(&quot;链表中没有此数据&quot;);            return;        }    }    //运行到此，证明有该结点    int del=tempBody;    tempBody=body;    //找到该结点的上一个结点，做删除操作    while (array[tempBody].cur!=del)     {        tempBody=array[tempBody].cur;    }    //将被删除结点的游标直接给被删除结点的上一个结点    array[tempBody].cur=array[del].cur;    //回收被摘除节点的空间    freeArr(array, del);}</code></pre><h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。</p><pre><code>//在以body作为头结点的链表中查找数据域为elem的结点在数组中的位置int selectElem(component *array,int body,char elem){    int tempBody=body;    //当游标值为0时，表示链表结束    while (array[tempBody].cur!=0)     {        if (array[tempBody].data==elem)         {            return tempBody;        }        tempBody=array[tempBody].cur;    }    return -1;//返回-1，表示在链表中没有找到该元素}</code></pre><h2 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h2><p>更改静态链表中的数据，只需找到目标元素所在的节点，直接更改节点中的数据域即可。</p><pre><code>//在以body作为头结点的链表中将数据域为oldElem的结点，数据域改为newElemvoid amendElem(component *array,int body,char oldElem,char newElem){    int add=selectElem(array, body, oldElem);    if (add==-1)    {        printf(&quot;无更改元素&quot;);        return;    }    array[add].data=newElem;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Static LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub搭建博客</title>
    <link href="undefined2019/09/29/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/09/29/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>#关于hexo与github使用过程中的问题与笔记</p><p><strong>一、搭建个人博客前提：</strong></p><p><strong><em>Node.js、git</em></strong> 环境安装</p><p><strong>二、Hexo安装</strong></p><p>安装Hexo</p><pre><code>npm install hexo -cli -g #安装hexo模块hexo init blog #通过hexo创建一个blog项目cd blog #打开blog文件夹npm installhexo server #开发服务</code></pre><p><strong>三、使用github</strong></p><p>GitHub中创建一个与用户名一致的仓库，以 <strong><em>io</em></strong> 为后缀，且一个账户只能建立一个。</p><p>如建立一个名叫<code>injoinD.github.io</code>的仓库，其中<code>injoinD</code>为用户名。</p><p><strong>四、配置git信息（Hexo和GitHub之间利用SSH通信）</strong></p><p>1.设置Git的user name和Email：</p><pre><code>git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;</code></pre><p>2.生成密钥</p><pre><code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></pre><p>打开以.ssh结尾的文件夹，将里面的内容配置到GitHub项目里的SSH and GPG keys中</p><p><strong>五、配置Deployment</strong></p><blockquote><p>在blog项目根目录下找到_config.yml文件，找到Deployment，做出如下修改：</p></blockquote><pre><code>deploy:  type: git  repo: git@github.com:yourname/yourname.github.io.git  branch: master</code></pre><p>如：仓库地址是<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:injoinD/injoinD.github.io.git,所以配置如下：</p><pre><code>deploy:  type: git  repo: git@github.com:injoinD/injoinD.github.io.git  branch: master</code></pre><p><strong>六、安装hexo-diployer-git自动部署发布工具</strong></p><pre><code>npm install hexo-deployer-git --save</code></pre><p><strong>七、生成静态文件部署到GitHub</strong></p><p>通过hexo命令，发布到GitHub上</p><pre><code>hexo g #生成网站静态文件到默认设置的 public 文件夹hexo d #自动生成网站静态文件，并部署到设定的仓库hexo clean #清除缓存文件 db.json 和已生成的静态文件 public</code></pre><p><strong><em>通过链接 injoinD.github.io即可访问 injoinD为自己的用户名</em></strong> </p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法小结</title>
    <link href="undefined2019/09/29/MarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <url>2019/09/29/MarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>#MarkDown语法小结</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用 <code>#</code> 表示标题，一级标题使用一个 <code>#</code> ，二级标题使用两个 <code>##</code> ，以此类推，共有六级标题。</li><li>使用 <code>=====</code> 表示高阶标题，使用 <code>---------</code> 表示次阶标题。</li></ul><ol><li><code>#</code> 和标题之间记得有个空格哦。</li><li><code>====</code> 和 <code>----</code> 表示标题时，大于等于2个都可以表示。</li><li>我通常在标题分级时使用标题标记，这个的用处很明了了。</li></ol><p>示例1</p><pre><code># 这是一级标题这也是一级标题========## 这是二级标题这也是二级标题--------------</code></pre><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h2 id="这也是二级标题"><a href="#这也是二级标题" class="headerlink" title="这也是二级标题"></a>这也是二级标题</h2><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>使用 <code>&gt;</code> 表示引用， <code>&gt;&gt;</code> 表示引用里面再套一层引用，依次类推。</p><ol><li>如果 <code>&gt;</code> 和 <code>&gt;&gt;</code> 嵌套使用的话，从 <code>&gt;&gt;</code> 退到 <code>&gt;</code> 时，必须之间要加一个空格或者 <code>&gt;</code> 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。</li><li>引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。</li></ol><p>示例</p><pre><code>&gt; 这是一级引用&gt;&gt;这是二级引用&gt;&gt;&gt; 这是三级引用&gt;这是一级引用</code></pre><blockquote><p>这是一级引用</p><blockquote><p>这是二级引用</p><blockquote><p>这是三级引用</p></blockquote></blockquote></blockquote><blockquote><p>这是一级引用</p></blockquote><h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3 代码块"></a>3 代码块</h3><p>使用3个连续的”`”符号包围起来表示代码块。</p><ol><li>本文档所有使用讲解Markdown语法标记示例的地方都是使用代码块标记的。</li><li>代码块前后都得有换行哦</li></ol><pre><code>$(document).ready(function() {  $(&#39;pre code&#39;).each(function(i, block) {    hljs.highlightBlock(block);  });});</code></pre><h3 id="4-行内代码"><a href="#4-行内代码" class="headerlink" title="4 行内代码"></a>4 行内代码</h3><p>使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。</p><p>示例</p><pre><code>这是`javascript`代码</code></pre><p>这是 <code>javascript</code> 代码</p><h4 id="5-链接"><a href="#5-链接" class="headerlink" title="5 链接"></a>5 链接</h4><p>使用 <code>[](link)</code> 表示行内链接。其中：</p><ul><li><code>[]</code> 内的内容为要添加链接的文字。</li><li><code>link</code> 为链接地址。</li></ul><p>示例</p><pre><code>我觉得[Markdown](https://appsto.re/cn/jK8Cbb.i)真是个方便的编辑器.</code></pre><p>我觉得<a href="https://appsto.re/cn/jK8Cbb.i" target="_blank" rel="noopener">Markdown</a>真是个方便的编辑器.</p><h3 id="6-数学公式"><a href="#6-数学公式" class="headerlink" title="6 数学公式"></a>6 数学公式</h3><p><code>$</code>包围的区块将会解析为数学公式，连续的<code>$$</code>将独占一行并居中显示</p><p>当 $a \ne 0$, 此方程式有两个解 $ax^2 + bx + c = 0$，他们是 </p><p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p><h3 id="7-导入图片"><a href="#7-导入图片" class="headerlink" title="7 导入图片"></a>7 导入图片</h3><p>使用 <code>![Alt text](/path/to/img.jpg)</code> 导入图片。其中：</p><ul><li><code>Alt text</code> 为如果图片无法显示时显示的文字；</li><li><code>/path/to/img.jpg</code> 为图片所在路径；</li></ul><p>点击辅助键盘中的添加图片按钮，<strong>Markdown</strong>会自动帮你帮你把图片上传到图片存储服务器，并补齐链接</p><p>示例</p><pre><code>![Markdown](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1569701098939&amp;di=ff20e6935f1d4085402df94ed4f5cc4a&amp;imgtype=0&amp;src=http%3A%2F%2Fcn.hdwall365.com%2Fwallpapers%2F1509%2FSydney-Opera-House-Australia-night-bridge-lights-sea-blue_m.jpg)</code></pre><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1569701098939&di=ff20e6935f1d4085402df94ed4f5cc4a&imgtype=0&src=http%3A%2F%2Fcn.hdwall365.com%2Fwallpapers%2F1509%2FSydney-Opera-House-Australia-night-bridge-lights-sea-blue_m.jpg" srcset="/img/loading.gif" alt="Markdown"></p><h3 id="8-ToDo-List"><a href="#8-ToDo-List" class="headerlink" title="8 ToDo List"></a>8 ToDo List</h3><pre><code>- [x] 支持数学公式- [x] 支持TodoList- [ ] 支持自定义样式- [ ] 支持自定义图床</code></pre><p>小写x表示已完成， 空格表示未完成</p><ul><li><input checked disabled type="checkbox"> 支持数学公式</li><li><input checked disabled type="checkbox"> 支持TodoList</li><li><input disabled type="checkbox"> 支持自定义样式</li><li><input disabled type="checkbox"> 支持自定义图床</li></ul><h3 id="9-粗体和斜体"><a href="#9-粗体和斜体" class="headerlink" title="9 粗体和斜体"></a>9 粗体和斜体</h3><ol><li>使用 <code>**</code> 或者 <code>__</code> 表示粗体。</li><li>使用 <code>*</code> 或者 <code>_</code> 表示斜体。</li><li>前后的 <code>*</code> 或 <code>_</code> 与要 <strong>加粗或倾斜</strong> 的字体之间不能有空格。</li></ol><p>示例</p><pre><code> **粗体** *斜体*</code></pre><p><strong>粗体</strong></p><p><em>斜体</em></p><h3 id="10-列表"><a href="#10-列表" class="headerlink" title="10 列表"></a>10 列表</h3><p>使用 <code>1. 2. 3.</code> 表示有序列表，使用 <code>*</code> 或 <code>-</code> 或 <code>+</code> 表示无序列表。</p><ol><li>无序列表或有序列表标记和后面的文字之间要有一个空格隔开。</li><li>有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。</li><li>无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例2所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。</li></ol><h4 id="例1：有序列表"><a href="#例1：有序列表" class="headerlink" title="例1：有序列表"></a>例1：有序列表</h4><pre><code>1. 第一点2. 第二点4. 第三点</code></pre><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><h4 id="例2：无序列表"><a href="#例2：无序列表" class="headerlink" title="例2：无序列表"></a>例2：无序列表</h4><pre><code>+ 一级无序列表内容    * 二级无序列表内容    - 二级无序列表内容        - 三级无序列表内容        - 三级无序列表内容+ 一级无序列表内容    - 二级无序列表内容</code></pre><ul><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul><ul><li>二级无序列表内容<ul><li>三级无序列表内容</li><li>三级无序列表内容</li></ul></li></ul></li><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul></li></ul><h3 id="11-分割线"><a href="#11-分割线" class="headerlink" title="11 分割线"></a>11 分割线</h3><p>使用 <code>---</code> 或者 <code>***</code> 或者 <code>* * *</code> 表示水平分割线。</p><ol><li>只要 <code>*</code> 或者 <code>-</code> 大于等于三个就可组成一条平行线。</li><li>使用 <code>---</code> 作为水平分割线时，要在它的前后都空一行，防止 <code>---</code> 被当成标题标记的表示方式。</li></ol><p>示例</p><pre><code>---**** * *</code></pre><h3 id="12-删除线"><a href="#12-删除线" class="headerlink" title="12 删除线"></a>12 删除线</h3><p>使用 <code>~~</code> 表示删除线。</p><ol><li>注意 <code>~~</code> 和 要添加删除线的文字之间不能有空格。</li><li>我常使用在显示的告诉自己这行文字是要删除的。</li></ol><p>示例</p><pre><code>~~这是一条删除线~~</code></pre><p><del>这是一条删除线</del></p><h3 id="13表格"><a href="#13表格" class="headerlink" title="13表格"></a>13表格</h3><p>上面空一行下面空两行</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>添加边框:</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>对齐方式:</p><table><thead><tr><th align="left">Heading</th><th align="center">Heading</th><th align="right">Heading</th></tr></thead><tbody><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git&amp;github学习总结</title>
    <link href="undefined2019/09/26/Git&amp;GitHub%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>2019/09/26/Git&amp;GitHub%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="git-amp-github学习总结"><a href="#git-amp-github学习总结" class="headerlink" title="git&amp;github学习总结"></a>git&amp;github学习总结</h1><h3 id="1-Git的优势"><a href="#1-Git的优势" class="headerlink" title="1.Git的优势"></a>1.Git的优势</h3><ul><li>大部分操作在本地完成，不需要联网</li><li>完整性保证</li><li>尽可能添加数据而不是删除或修改数据</li><li>分支操作非常快捷流畅</li><li>与 Linux 命令全面兼容</li></ul><h3 id="2-Git的基本操作"><a href="#2-Git的基本操作" class="headerlink" title="2.Git的基本操作"></a>2.Git的基本操作</h3><ul><li><strong>2.1 状态查看</strong></li></ul><p><code>git stastus</code></p><blockquote><p>查看工作区、暂存区的状态</p></blockquote><ul><li><strong>2.2 添加</strong></li></ul><p><code>git add [file name]</code></p><blockquote><p>将工作区的“新建/修改”添加到暂存区</p></blockquote><ul><li><strong>2.3 提交</strong></li></ul><p><code>git commit -m &quot;commit message&quot; [file name]</code></p><blockquote><p>将暂存区的内容提交到本地库 </p></blockquote><ul><li><strong>2.4 查看历史记录</strong></li></ul><p><code>git log</code></p><blockquote><p>多屏显示控制方式： 空格向下翻页 b 向上翻页 q 退出</p></blockquote><ul><li><strong>2.5 前进后退</strong></li></ul><p><strong><em>本质：HEAD指针移动</em></strong></p><p>基于索引值操作[推荐]</p><p><code>git reset --hard [局部索引值]</code></p><p><code>git reset --hard a6ace91</code></p><blockquote><p>使用^符号：只能后退</p></blockquote><p><code>git reset --hard HEAD^</code></p><blockquote><p>注：一个^表示后退一步，n个表示后退n步<br>使用~符号：只能后退</p></blockquote><p><code>git reset --hard HEAD~n</code></p><blockquote><p>注：表示后退n步</p></blockquote><ul><li><p><strong>2.6 reset命令的三个参数对比</strong></p><ul><li><p>1.<br><code>--soft 参数</code></p><blockquote><p>仅仅在本地库移动HEAD指针</p></blockquote></li><li><p>2.<br><code>--mixed 参数</code></p><blockquote><p>在本地库移动 HEAD 指针</p><p>重置暂存区</p></blockquote></li><li><p>3.<br><code>--hard 参数</code></p><blockquote><p>在本地库移动HEAD指针</p><p>重置暂存区</p><p>重置工作区</p></blockquote></li></ul></li></ul><ul><li><p><strong>2.7 删除文件并找回</strong></p><ul><li>前提：删除前，文件存在时的状态提交到了本地库。</li><li>操作：<code>git reset --hard [指针位置]</code></li></ul></li></ul><pre><code>    &gt;删除操作已经提交到本地库：指针位置指向历史记录    &gt;    &gt;删除操作尚未提交到本地库：指针位置使用 HEAD</code></pre><ul><li><p><strong>2.8 比较文件差异</strong></p><ul><li><p><code>git diff [文件名]</code></p><blockquote><p>将工作区中的文件和暂存区进行比较</p></blockquote></li><li><p><code>git diff [本地库中历史版本] [文件名]</code></p><blockquote><p>将工作区中的文件和本地库历史记录比较 </p><p>不带文件名比较多个文件</p></blockquote></li></ul></li></ul><h3 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3.分支管理"></a>3.分支管理</h3><ul><li><p>3.1 什么是分支？ </p><pre><code>在版本控制过程中，使用多条线同时推进多个任务。</code></pre></li><li><p>3.2 分支的好处？</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任 何影响。失败的分支删除重新开始即可。 </li></ul></li><li><p>3.3 分支操作</p><ul><li><p>创建分支 <code>git branch [分支名]</code></p></li><li><p>查看分支 <code>git branch -v</code></p></li><li><p>切换分支 <code>git checkout [分支名]</code></p></li><li><p>合并分支</p><ul><li><p>第一步：切换到接受修改的分支（被合并，增加新内容）上 </p><p>   <code>git checkout [被合并分支名]</code></p></li><li><p>第二步：执行 <strong>merge</strong> 命令 </p><pre><code>`git merge [有新内容分支名]`</code></pre></li></ul></li></ul></li><li><p>3.4 冲突的解决</p><ul><li><p>第一步：编辑文件，删除特殊符号</p></li><li><p>第二步：把文件修改到满意的程度，保存退出</p></li><li><p>第三步：<code>git add [文件名]</code></p></li><li><p>第四步：<code>git commit -m &quot;日志信息&quot;</code></p><p>   <strong>注意：此时 commit 一定不能带具体文件名</strong></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dddddwen</title>
    <link href="undefined2019/09/25/duwen/"/>
    <url>2019/09/25/duwen/</url>
    
    <content type="html"><![CDATA[<p>搭博客的过程中虽然遇到了很多问题，但还是成功解决，拥有了属于自己的博客。</p><p>然后最近进入工作室的学习中，接触了很多新知识，现在只是略懂皮毛，希望快快将这些基础消化。</p><p>很感谢工作室各位的帮助，还是要谢谢宁哥，每周检查学习情况的制度不断督促着我，能让我按时完成学习任务。</p><p>最近逐渐开始步入正轨，接下来就要百分六十投入工作室，百分四十投入学习，在2019最后的三个月里，我想我会收获很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/25/hello-world/"/>
    <url>2019/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>